<!doctype html><html lang=en>
<head>
<script async defer data-website-id=6023252a-3a97-470f-b4ee-5082d242bb9a src=https://umami.pourtan.eu/umami.js></script>
<meta charset=utf-8>
<meta name=generator content="Hugo 0.88.1">
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=author content="Max Halford">
<meta property="og:url" content="https://maxhalford.github.io/blog/halftoning-2/">
<link rel=canonical href=https://maxhalford.github.io/blog/halftoning-2/>
<link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦”</text></svg>">
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/maxhalford.github.io\/"},"articleSection":"blog","name":"Halftoning with Go - Part 2","headline":"Halftoning with Go - Part 2","description":"The next stop on my travel through the world of halftoning will be the implementation of Weighted Voronoi Stippling as described in Adrian Secord\u0026rsquo;s 2002 paper. This method is more involved than the ones I detailed in my previous blog post, however the results are quite interesting. Again, I did the implementation in Go.\nNotice the black dot in the middle of the white square?   Overview I found a fair amount of resources about the method, most of them being implementations of Adrian Secord\u0026rsquo;s paper.","inLanguage":"en-US","author":"Max Halford","creator":"Max Halford","publisher":"Max Halford","accountablePerson":"Max Halford","copyrightHolder":"Max Halford","copyrightYear":"2017","datePublished":"2017-03-20 00:00:00 \u002b0000 UTC","dateModified":"2017-03-20 00:00:00 \u002b0000 UTC","url":"https:\/\/maxhalford.github.io\/blog\/halftoning-2\/","keywords":[]}</script>
<title>Halftoning with Go - Part 2 - Max Halford</title>
<meta property="og:title" content="Halftoning with Go - Part 2 - Max Halford">
<meta property="og:type" content="article">
<meta name=description content="The next stop on my travel through the world of halftoning will be the implementation of Weighted Voronoi Stippling as described in Adrian Secord&rsquo;s 2002 paper. This method is more involved than the ones I detailed in my previous blog post, however the results are quite interesting. Again, I did the implementation in Go.
Notice the black dot in the middle of the white square?   Overview I found a fair amount of resources about the method, most of them being implementations of Adrian Secord&rsquo;s paper.">
<link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css>
<link rel=stylesheet href=/css/github-markdown.min.css>
<link rel=stylesheet href=/css/highlight/github.css>
<link rel=stylesheet href=/css/index.css>
<link rel=preconnect href=https://fonts.gstatic.com>
<link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Permanent+Marker&display=swap" rel=stylesheet>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0,tags:'ams'},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll('mjx-container').forEach(function(a){a.parentElement.classList+='has-jax'})})</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
</head>
<body>
<article class=post id=article>
<div class="row center-xs" style=text-align:left>
<div class="col-xs-12 col-sm-10 col-md-7 col-lg-5">
<div class=post-header>
<header>
<div class="signatures site-title">
<a href=/>Max Halford</a>
</div>
</header>
<div class="row end-xs">
<div>
<a class=header-link href=/>Blog</a>
<a class=header-link href=/links/>Links</a>
<a class=header-link href=/bio/>Bio</a>
</div>
</div>
<div class=header-line></div>
</div>
<header class=post-header>
<h1 class=post-title>Halftoning with Go - Part 2</h1>
<div class="row post-desc">
<div class=col-xs-12>
<time class=post-date datetime="2017-03-20 00:00:00 UTC">
2017-03-20 Â· 19 minute read
</time>
</div>
</div>
</header>
<div class="post-content markdown-body">
<p>The next stop on my travel through the world of halftoning will be the implementation of <em>Weighted Voronoi Stippling</em> as described in <a href=https://cs.nyu.edu/~ajsecord/>Adrian Secord</a>&rsquo;s 2002 <a href=http://www.mrl.nyu.edu/~ajsecord/npar2002/npar2002_ajsecord_preprint.pdf>paper</a>. This method is more involved than the ones I detailed in my <a href=/blog/halftoning-1>previous blog post</a>, however the results are quite interesting. Again, I did the implementation in Go.</p>
<div align=center>
<figure style=width:80%>
<img src=/img/blog/halftoning-2/coliseum.jpg alt=colosseum>
<img src=/img/blog/halftoning-2/coliseum_stippled.jpg alt=colosseum_stippled>
<figcaption>Notice the black dot in the middle of the white square?</figcaption>
</figure>
</div>
<h2 id=overview>Overview</h2>
<p>I found a fair amount of resources about the method, most of them being implementations of Adrian Secord&rsquo;s paper. However, not many of these resources went into the nitty-gritty details which are not obvious for beginners in image processing. Before delving into the code, I want to go through some concepts that may seem obvious to some readers but that I judge worthy of detailing.</p>
<p>In art, <a href=https://www.wikiwand.com/en/Stippling>stippling</a> is a process where single-colored dots are laid out on a white image so as to reproduce an image. The denser the dots, the darker the area they cover. The visual appeal of stippled images comes from the way the dots are laid out. A good stippling method generates evenly spaces dots which makes the image seem <em>organized</em>. This kind of harmonious distribution is often referred to as <a href=https://www.wikiwand.com/en/Colors_of_noise#/Blue_noise>blue noise</a> and is notoriously difficult to generate.</p>
<p>Adrian Secord&rsquo;s idea - inspired Oliver Deussen&rsquo;s previous work from 2000 - is to use <em>weighted centroidal Voronoi diagrams</em> to place the dots. Although the name may seem far fetched, the underlying idea is very simple and can be broken down into three parts.</p>
<p><a href=https://www.wikiwand.com/en/Voronoi_diagram>Voronoi diagrams</a> (also called <em>Voronoi tessellations</em>) are a huge topic and are surprisingly used in many areas of research. A Voronoi diagram consists of a number of <em>sites</em> and <em>regions</em>. To each site there belongs a region wherein each point has a shorter distance to the site than it does to any other site. In an image, the sites would a list of $(x, y)$ pairs with discrete coordinates; to generate the Voronoi diagram we would iterate over each pixel in the image, calculate the distance to each site and then assign each pixel to the site to which it is closest. This is one of way of generating Voronoi diagrams, however it obliges us to use integers which isn&rsquo;t very handy when doing fine-grained image processing. A Voronoi diagram can also be seen as a set of vertices and edges which can be obtained by using <a href="https://www.wikiwand.com/en/Fortune's_algorithm">Fortune&rsquo;s algorithm</a>. As we will see this representation doesn&rsquo;t suit our purpose and we have to stick to the sites/regions representation. I&rsquo;ll detail the method I used in a further section.</p>
<div align=center>
<figure style=width:60%>
<img src=/img/blog/halftoning-2/voronoi_diagram.png alt=voronoi_diagram>
<figcaption>Altogether not a very exciting image, right?</figcaption>
</figure>
</div>
<p>A <a href=https://www.wikiwand.com/en/Centroidal_Voronoi_tessellation><em>Centroidal Voronoi diagram</em></a> is a Voronoi diagram where the sites are at the <em>centroid</em> of their respective region. Because each region is a polygon, their exists a <a href=https://www.wikiwand.com/en/Centroid#/Centroid_of_polygon>formula</a> for calculating the centroids by looking at the vertices. However, a more intuitive way of calculating a polygon centroid is:</p>
<p>$$c_x = \frac{1}{|S|} \int_S x dS$$</p>
<p>$$c_y = \frac{1}{|S|} \int_S y dS$$</p>
<p>where $c_x$ and $c_y$ are respectively the $x$ and $y$ coordinates of a polygon defined by a set of points $S$. In English we are simply taking the average $x$ and $y$ coordinates as the centroids. We gain in simplicity what we lose in speed; the formula using the vertices is much faster. In our case we are dealing with images and discrete values; sums have to be used instead of integrals.</p>
<p>$$c_x = \frac{1}{|S|} \sum_{p \in S} p(x)$$</p>
<p>$$c_y = \frac{1}{|S|} \sum_{p \in S} p(y)$$</p>
<p>Producing a centroidal Voronoi diagram requires iterating the following steps:</p>
<ol>
<li>Calculate each region&rsquo;s centroid</li>
<li>Move the sites to their corresponding centroid</li>
<li>Reassign the points to their closest site</li>
</ol>
<p>This procedure is called <a href="https://www.wikiwand.com/en/Lloyd's_algorithm">Lloyd&rsquo;s algorithm</a> and is used in other algorithms just as <a href="https://www.wikiwand.com/en/Lloyd's_algorithm">k-means clustering</a>. As can be seen in the following image, after a few iterations - usually 15 does the trick - the regions start to have the same shape and size and seem to <em>organize</em> themselves.</p>
<div align=center>
<figure style=width:60%>
<img src=/img/blog/halftoning-2/centroidal_voronoi_diagram.jpg alt=centroidal_voronoi_diagram>
<figcaption>A centroidal Voronoi diagram</figcaption>
</figure>
</div>
<p>A weighted centroidal diagram is a centroidal Voronoi diagram where the centroids are calculated using a weighted average. In our case the weights are the gray scale intensities of an image. The idea is that we want the centroids to bundle around dark patches of an image and yet not to overlap. That&rsquo;s it, there is nothing more it; the results speak for themselves. The previous formulas are easy to adapt:</p>
<p>$$c_x = \frac{1}{W \times |S|} \sum_{p \in S} p(w) \times p(x)$$</p>
<p>$$c_y = \frac{1}{W \times |S|} \sum_{p \in S} p(w) \times p(y)$$</p>
<p>where $W = \sum_{p \in S} p(w)$. If this isn&rsquo;t clear bear with me until we get to the implementation, everything will seem clearer.</p>
<p>The following image was produced by using an gray scale image of a blank image with a circle in the center. By taking into account the gray scale values, the centroids move towards the center whilst remaining somewhat &ldquo;organized&rdquo;.</p>
<div align=center>
<figure style=width:60%>
<img src=/img/blog/halftoning-2/weighted_centroidal_voronoi_diagram.jpg alt=weighted_centroidal_voronoi_diagram>
<figcaption>A weighted centroidal Voronoi diagram</figcaption>
</figure>
</div>
<p>Now for the implementation!</p>
<h2 id=importance-sampling>Importance sampling</h2>
<p>An initial set of points is required for generating a Voronoi diagram. What&rsquo;s more, it would be nice to be able to control the number of points used for stippling. A simple solution is to sample a set of points completely at random. Although this works, it means that more iterations will be required to converge onto a weighted centroidal Voronoi diagram. A smarter way of doing is to sample points with a distribution based on the gray scale intensities of an image. In other words to sample more points where the image is dark and less where the image is light. This way of doing is called <em>importance sampling</em> because the darker pixels - the dark ones - will be sampled more that the light ones.</p>
<p>My implementation is inspired from the <a href=https://www.wikiwand.com/en/Fitness_proportionate_selection>roulette wheel selection algorithm</a> used in genetic algorithms:</p>
<ol>
<li>Created a weighted roulette with decreasing pocket sizes and one pocket per gray scale intensity</li>
<li>Choose a random number between 0 and the sum of the pocket sizes</li>
<li>See in which pocket the random number falls</li>
<li>Pick a random point with the obtained intensity</li>
</ol>
<p>In our case the gray scale intensities go from 0 to 255, hence we will have 256 pockets. If we picked a random number between 0 and 255 then we would be picking intensities completely at random. We want to pick darker intensities more often, hence we are going to &ldquo;weight&rdquo; the pockets with the intensities. This is quite simple, each pocket will simply have a size/weight of $256 - i$ where $i$ is the intensity; this way the darker intensities - the ones closer to 0 - will have a higher waits.</p>
<div align=center>
<figure style=width:60%>
<img src=/img/blog/halftoning-2/roulette_wheel.png alt=roulette_wheel>
<figcaption>A "flattened" roulette wheel</figcaption>
</figure>
</div>
<p>To be able to &ldquo;run&rdquo; the wheel we need to generate numbers and see in which pocket they lie. To do so we have to generate a cumulative roulette wheel and generate a random number between 0 and the last roulette wheel value.</p>
<div align=center>
<figure style=width:60%>
<img src=/img/blog/halftoning-2/cumulative_roulette_wheel.png alt=roulette_wheel>
<figcaption>The cumulative version of the roulette wheel</figcaption>
</figure>
</div>
<p>The code for creating the cumulative roulette wheel is quite simple.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>roulette</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>256</span><span class=p>)</span>
<span class=nx>roulette</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>256</span>
<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>roulette</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
    <span class=nx>roulette</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>roulette</span><span class=p>[</span><span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=p>(</span><span class=mi>256</span> <span class=o>-</span> <span class=nx>i</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>We also need some sort of data structure to map intensities to matching points. This can simply be a hash table where the keys are the intensities and the values are the belonging points.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=p>(</span>
    <span class=nx>bounds</span> <span class=p>=</span> <span class=nx>gray</span><span class=p>.</span><span class=nf>Bounds</span><span class=p>()</span>
    <span class=nx>hist</span>   <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>uint8</span><span class=p>]</span><span class=nx>Points</span><span class=p>)</span>
<span class=p>)</span>
<span class=k>for</span> <span class=nx>x</span> <span class=o>:=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nx>Min</span><span class=p>.</span><span class=nx>X</span><span class=p>;</span> <span class=nx>x</span> <span class=p>&lt;</span> <span class=nx>bounds</span><span class=p>.</span><span class=nx>Max</span><span class=p>.</span><span class=nx>X</span><span class=p>;</span> <span class=nx>x</span><span class=o>++</span> <span class=p>{</span>
    <span class=k>for</span> <span class=nx>y</span> <span class=o>:=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nx>Min</span><span class=p>.</span><span class=nx>Y</span><span class=p>;</span> <span class=nx>y</span> <span class=p>&lt;</span> <span class=nx>bounds</span><span class=p>.</span><span class=nx>Max</span><span class=p>.</span><span class=nx>Y</span><span class=p>;</span> <span class=nx>y</span><span class=o>++</span> <span class=p>{</span>
        <span class=kd>var</span> <span class=nx>intensity</span> <span class=p>=</span> <span class=nx>gray</span><span class=p>.</span><span class=nf>GrayAt</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>).</span><span class=nx>Y</span>
        <span class=nx>hist</span><span class=p>[</span><span class=nx>intensity</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>hist</span><span class=p>[</span><span class=nx>intensity</span><span class=p>],</span> <span class=nx>Point</span><span class=p>{</span><span class=nb>float64</span><span class=p>(</span><span class=nx>x</span><span class=p>),</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>y</span><span class=p>)})</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>In the above snippet <code>gray</code> is an <code>image.Image</code> from Go&rsquo;s standard library. The <code>Point</code> struct is a custom one where the coordinates are floating point numbers. Go&rsquo;s <code>image.Point</code> doesn&rsquo;t suit our particular needs because it&rsquo;s coordinates are integers.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Point</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>X</span> <span class=kt>float64</span>
    <span class=nx>Y</span> <span class=kt>float64</span>
<span class=p>}</span>
</code></pre></div><p>The final step is to generate random numbers and see in which pocket they lie. Once we generate a number, we could simply iterate through the roulette wheel and check for the first index whose value is above the generated number. However the values in our roulette wheel are sorted, hence we can use <a href=https://www.wikiwand.com/en/Binary_search_algorithm>binary search</a> to speed things up. Conveniently Go&rsquo;s standard library contains a <a href=https://golang.org/pkg/sort/#Search><code>sort.Search</code></a> method which does exactly what we need; a <a href=https://golang.org/pkg/sort/#SearchInts><code>sort.SearchInts</code></a> convenience method even exists. The following snippet contains my final implementation of importance sampling.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>ImportanceSample</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>gray</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span><span class=p>,</span> <span class=nx>threshold</span> <span class=kt>uint8</span><span class=p>,</span> <span class=nx>rng</span> <span class=o>*</span><span class=nx>rand</span><span class=p>.</span><span class=nx>Rand</span><span class=p>)</span> <span class=nx>Points</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=p>(</span>
        <span class=nx>pts</span>    <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Points</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
        <span class=nx>bounds</span> <span class=p>=</span> <span class=nx>gray</span><span class=p>.</span><span class=nf>Bounds</span><span class=p>()</span>
        <span class=nx>hist</span>   <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>uint8</span><span class=p>]</span><span class=nx>Points</span><span class=p>)</span>
    <span class=p>)</span>
    <span class=c1>// Build a histogram
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>x</span> <span class=o>:=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nx>Min</span><span class=p>.</span><span class=nx>X</span><span class=p>;</span> <span class=nx>x</span> <span class=p>&lt;</span> <span class=nx>bounds</span><span class=p>.</span><span class=nx>Max</span><span class=p>.</span><span class=nx>X</span><span class=p>;</span> <span class=nx>x</span><span class=o>++</span> <span class=p>{</span>
        <span class=k>for</span> <span class=nx>y</span> <span class=o>:=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nx>Min</span><span class=p>.</span><span class=nx>Y</span><span class=p>;</span> <span class=nx>y</span> <span class=p>&lt;</span> <span class=nx>bounds</span><span class=p>.</span><span class=nx>Max</span><span class=p>.</span><span class=nx>Y</span><span class=p>;</span> <span class=nx>y</span><span class=o>++</span> <span class=p>{</span>
            <span class=kd>var</span> <span class=nx>intensity</span> <span class=p>=</span> <span class=nx>gray</span><span class=p>.</span><span class=nf>GrayAt</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>).</span><span class=nx>Y</span>
            <span class=k>if</span> <span class=nx>intensity</span> <span class=o>&lt;=</span> <span class=nx>threshold</span> <span class=p>{</span>
                <span class=nx>hist</span><span class=p>[</span><span class=nx>intensity</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>hist</span><span class=p>[</span><span class=nx>intensity</span><span class=p>],</span> <span class=nx>Point</span><span class=p>{</span><span class=nb>float64</span><span class=p>(</span><span class=nx>x</span><span class=p>),</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>y</span><span class=p>)})</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// Build a roulette wheel
</span><span class=c1></span>    <span class=kd>var</span> <span class=nx>roulette</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>threshold</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
    <span class=nx>roulette</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>256</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>roulette</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>roulette</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>roulette</span><span class=p>[</span><span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=p>(</span><span class=mi>256</span> <span class=o>-</span> <span class=nx>i</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>// Run the wheel
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>pts</span> <span class=p>{</span>
        <span class=kd>var</span> <span class=p>(</span>
            <span class=nx>ball</span> <span class=p>=</span> <span class=nx>rng</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=nx>roulette</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>roulette</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
            <span class=nx>bin</span>  <span class=p>=</span> <span class=nx>sort</span><span class=p>.</span><span class=nf>SearchInts</span><span class=p>(</span><span class=nx>roulette</span><span class=p>,</span> <span class=nx>ball</span><span class=p>)</span>
            <span class=nx>p</span>    <span class=p>=</span> <span class=nx>hist</span><span class=p>[</span><span class=nb>uint8</span><span class=p>(</span><span class=nx>bin</span><span class=p>)][</span><span class=nx>rng</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>hist</span><span class=p>[</span><span class=nb>uint8</span><span class=p>(</span><span class=nx>bin</span><span class=p>)]))]</span>
        <span class=p>)</span>
        <span class=nx>p</span><span class=p>.</span><span class=nx>X</span> <span class=o>+=</span> <span class=nx>rng</span><span class=p>.</span><span class=nf>Float64</span><span class=p>()</span>
        <span class=nx>p</span><span class=p>.</span><span class=nx>Y</span> <span class=o>+=</span> <span class=nx>rng</span><span class=p>.</span><span class=nf>Float64</span><span class=p>()</span>
        <span class=nx>pts</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>p</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>pts</span>
<span class=p>}</span>
</code></pre></div><p>We want to generate <code>n</code> points which we store in a slice called <code>pts</code>. We start by building a hash table mapping each intensity to a set of matching of points. I added a <code>threshold</code> parameter so that higher intensities - the ones closer to white - are discarded. Next we build the roulette wheel; because of the <code>threshold</code> parameter the values above it are not taken into account in the roulette wheel. Finally we generate a random number - called <code>ball</code> - and we use <code>sort.SearchInts</code> to obtain the intensity from which to sample a random point <code>p</code> in the hash table <code>hist</code>. I added some noise to the sampled points in case a point is sampled twice. Here is an example of applying the method with a sample of size 10000.</p>
<div align=center>
<figure style=width:60%>
<img src=/img/blog/halftoning-2/plant.png alt=importance_sampling>
<figcaption>One of the images Adrian Secord used in his paper</figcaption>
</figure>
</div>
<div align=center>
<figure style=width:60%>
<img src=/img/blog/halftoning-2/importance_sampling.png alt=importance_sampling>
<figcaption>Importance sampling with 10000 points</figcaption>
</figure>
</div>
<p>I don&rsquo;t want to spend more time going through the intricacies of importance sampling because it is a bit off topic. If you&rsquo;re interested I&rsquo;ve added the method to the <a href=https://github.com/MaxHalford/halfgone#importance-sampling>halfgone package</a>. The main idea to take away is that I wanted a method that could produce a fixed number of points with a distribution somewhat reproducing the darkness of the image. If you want to implement Weighted Voronoi Stippling yourself, you&rsquo;ll do just fine by generating a initial set of points completely at random!</p>
<h2 id=using-a-kd-tree-for-computing-voronoi-diagrams>Using a kd-tree for computing Voronoi diagrams</h2>
<p>Now that we have an initial set of points, we are going to use Lloyd&rsquo;s algorithm for &ldquo;relaxing&rdquo; the points in a harmonious disposition. However, to do so we need to be able to build a Voronoi diagram because the relaxation step involves points towards their Voronoi region centroid.</p>
<p>As mentioned earlier, obtaining the vertices and edges that define a Voronoi diagram isn&rsquo;t enough if we want to compute weighted centroids. We need to be able to know the coordinates and the weights of each point belonging to a region to be able to calculate it&rsquo;s region. A naive way of doing is to iterate through each point of an image and to determine it&rsquo;s closest site by calculating the distance towards each site. This is called <a href=https://www.wikiwand.com/en/Nearest_neighbor_search>nearest neighbour search</a> and is a well known problem in computer science; there are many data structures that make it possible to save a lot of time.</p>
<p>I settled on using a <a href=https://www.wikiwand.com/en/K-d_tree>kd-tree</a>; I don&rsquo;t want to delve into it too far because there are already many existing resources online. I based myself on <a href=https://www.ri.cmu.edu/pub_files/pub1/moore_andrew_1991_1/moore_andrew_1991_1.pdf>this tutorial</a> from Carnegie Mellon. I used three Go structs for the implementation.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>rectangle</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>min</span><span class=p>,</span> <span class=nx>max</span> <span class=nx>Point</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>kdNode</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>p</span>           <span class=nx>Point</span>
    <span class=nx>splitByX</span>    <span class=kt>bool</span>
    <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=o>*</span><span class=nx>kdNode</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>kdTree</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>root</span>   <span class=o>*</span><span class=nx>kdNode</span>
    <span class=nx>bounds</span> <span class=nx>rectangle</span>
<span class=p>}</span>
</code></pre></div><p>The <code>rectangle</code> struct represents the &ldquo;boxes&rdquo; the kd-tree splits a two-dimensional into. A <code>kdNode</code> is an element of a <code>kdTree</code> and represents a splitting point. The <code>splitByX</code> field indicates if the node partitions the space in two left and right rectangles or two top and bottom ones. In a generic implementation the kd-tree would be applied to a multi-dimensional and <code>splitByX</code> would be replaced by an integer to indicate which dimension the split is applied to. The kd-tree algorithms has two phases: the building and the searching, in my implementation both are recursive.</p>
<p>The building part is the easiest part. Say we have a list of points $S$ and we want to build a kd-tree on top of it. We start with a dimension at random, for example the $x$-axis. The only thing we have to do is to find the point with the median $x$ value; this is easily done by sorting $S$ according to each points $x$ value and then choosing the value at the middle of the $S$. The point is then added to the kd-tree and we run the same thing we just did on the halves that were produced, hence the recursion I mentioned. The reason why median points are chosen can be understood from a heuristic point of view: having boxes more or less of the same size will narrow down the search space faster.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>makeKdTree</span><span class=p>(</span><span class=nx>pts</span> <span class=nx>Points</span><span class=p>,</span> <span class=nx>bounds</span> <span class=nx>rectangle</span><span class=p>)</span> <span class=nx>kdTree</span> <span class=p>{</span>

    <span class=kd>var</span> <span class=nx>split</span> <span class=kd>func</span><span class=p>(</span><span class=nx>pts</span> <span class=nx>Points</span><span class=p>,</span> <span class=nx>splitByX</span> <span class=kt>bool</span><span class=p>)</span> <span class=o>*</span><span class=nx>kdNode</span>

    <span class=nx>split</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>pts</span> <span class=nx>Points</span><span class=p>,</span> <span class=nx>splitByX</span> <span class=kt>bool</span><span class=p>)</span> <span class=o>*</span><span class=nx>kdNode</span> <span class=p>{</span>

        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>pts</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=k>return</span> <span class=kc>nil</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=nx>splitByX</span> <span class=p>{</span>
            <span class=nx>pts</span><span class=p>.</span><span class=nf>sortByX</span><span class=p>()</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=nx>pts</span><span class=p>.</span><span class=nf>sortByY</span><span class=p>()</span>
        <span class=p>}</span>

        <span class=nx>med</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>pts</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>

        <span class=k>return</span> <span class=o>&amp;</span><span class=nx>kdNode</span><span class=p>{</span>
            <span class=nx>p</span><span class=p>:</span>        <span class=nx>pts</span><span class=p>[</span><span class=nx>med</span><span class=p>],</span>
            <span class=nx>splitByX</span><span class=p>:</span> <span class=nx>splitByX</span><span class=p>,</span>
            <span class=nx>left</span><span class=p>:</span>     <span class=nf>split</span><span class=p>(</span><span class=nx>pts</span><span class=p>[:</span><span class=nx>med</span><span class=p>],</span> <span class=p>!</span><span class=nx>splitByX</span><span class=p>),</span>
            <span class=nx>right</span><span class=p>:</span>    <span class=nf>split</span><span class=p>(</span><span class=nx>pts</span><span class=p>[</span><span class=nx>med</span><span class=o>+</span><span class=mi>1</span><span class=p>:],</span> <span class=p>!</span><span class=nx>splitByX</span><span class=p>),</span>
        <span class=p>}</span>

    <span class=p>}</span>

    <span class=k>return</span> <span class=nx>kdTree</span><span class=p>{</span>
        <span class=nx>root</span><span class=p>:</span>   <span class=nf>split</span><span class=p>(</span><span class=nx>pts</span><span class=p>,</span> <span class=kc>true</span><span class=p>),</span>
        <span class=nx>bounds</span><span class=p>:</span> <span class=nx>bounds</span><span class=p>,</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>The points are either sorted along the $x$-axis by calling <code>pts.sortByX</code> or along the $y$-axis with <code>pts.sortByY</code> depending on the value of <code>splitByX</code>. Here is the code for <code>sortByX</code>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>pts</span> <span class=nx>Points</span><span class=p>)</span> <span class=nf>sortByX</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>sort</span><span class=p>.</span><span class=nf>Slice</span><span class=p>(</span><span class=nx>pts</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>pts</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>X</span> <span class=p>&lt;</span> <span class=nx>pts</span><span class=p>[</span><span class=nx>j</span><span class=p>].</span><span class=nx>X</span> <span class=p>})</span>
<span class=p>}</span>
</code></pre></div><p>Go can be a nice language, right? The median value is then obtained by dividing the length of the list of points and rounding it down with <code>med := len(pts) / 2</code>. Finally we call the <code>split</code> on each sub-list by slicing the original list on <code>med</code>.</p>
<p>The search phase is bit more complex and I don&rsquo;t want to go into it in detail, it&rsquo;s already quite well explained from page 6 in the Carnegie Mellon <a href=https://www.ri.cmu.edu/pub_files/pub1/moore_andrew_1991_1/moore_andrew_1991_1.pdf>tutorial</a>. Basically, the search starts by doing a depth-first search for the closest leaf node to the target point. As the tutorial explains, this is already a good approximation. However, if the circle with a radius equal to distance between the target point and the lead node overlaps the parent node&rsquo;s box, then the algorithms goes up a level and checks other branches for closer points. It&rsquo;s fine if you don&rsquo;t know how kd-trees work, the only thing to remember is that they are a data structure that allows us to search for nearest neighbours in a timely fashion. Nevertheless, here is the Go code for performing a search.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=nx>kdTree</span><span class=p>)</span> <span class=nf>findNearestNeighbour</span><span class=p>(</span><span class=nx>p</span> <span class=nx>Point</span><span class=p>)</span> <span class=p>(</span><span class=nx>best</span> <span class=nx>Point</span><span class=p>,</span> <span class=nx>bestSqd</span> <span class=kt>float64</span><span class=p>)</span> <span class=p>{</span>

    <span class=kd>var</span> <span class=nx>search</span> <span class=kd>func</span><span class=p>(</span><span class=nx>node</span> <span class=o>*</span><span class=nx>kdNode</span><span class=p>,</span> <span class=nx>target</span> <span class=nx>Point</span><span class=p>,</span> <span class=nx>r</span> <span class=nx>rectangle</span><span class=p>,</span> <span class=nx>maxDistSqd</span> <span class=kt>float64</span><span class=p>)</span>
    <span class=p>(</span><span class=nx>nearest</span> <span class=nx>Point</span><span class=p>,</span> <span class=nx>distSqd</span> <span class=kt>float64</span><span class=p>)</span>

    <span class=nx>search</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>node</span> <span class=o>*</span><span class=nx>kdNode</span><span class=p>,</span> <span class=nx>target</span> <span class=nx>Point</span><span class=p>,</span> <span class=nx>r</span> <span class=nx>rectangle</span><span class=p>,</span> <span class=nx>maxDistSqd</span> <span class=kt>float64</span><span class=p>)</span>
    <span class=p>(</span><span class=nx>nearest</span> <span class=nx>Point</span><span class=p>,</span> <span class=nx>distSqd</span> <span class=kt>float64</span><span class=p>)</span> <span class=p>{</span>

        <span class=k>if</span> <span class=nx>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>Point</span><span class=p>{},</span> <span class=nx>math</span><span class=p>.</span><span class=nf>Inf</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
        <span class=p>}</span>

        <span class=kd>var</span> <span class=nx>targetInLeft</span> <span class=kt>bool</span>
        <span class=kd>var</span> <span class=nx>leftBox</span><span class=p>,</span> <span class=nx>rightBox</span> <span class=nx>rectangle</span>
        <span class=kd>var</span> <span class=nx>nearestNode</span><span class=p>,</span> <span class=nx>furthestNode</span> <span class=o>*</span><span class=nx>kdNode</span>
        <span class=kd>var</span> <span class=nx>nearestBox</span><span class=p>,</span> <span class=nx>furthestBox</span> <span class=nx>rectangle</span>

        <span class=k>if</span> <span class=nx>node</span><span class=p>.</span><span class=nx>splitByX</span> <span class=p>{</span>
            <span class=nx>leftBox</span> <span class=p>=</span> <span class=nx>rectangle</span><span class=p>{</span><span class=nx>r</span><span class=p>.</span><span class=nx>min</span><span class=p>,</span> <span class=nx>Point</span><span class=p>{</span><span class=nx>node</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nx>X</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>max</span><span class=p>.</span><span class=nx>Y</span><span class=p>}}</span>
            <span class=nx>rightBox</span> <span class=p>=</span> <span class=nx>rectangle</span><span class=p>{</span><span class=nx>Point</span><span class=p>{</span><span class=nx>node</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nx>X</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>min</span><span class=p>.</span><span class=nx>Y</span><span class=p>},</span> <span class=nx>r</span><span class=p>.</span><span class=nx>max</span><span class=p>}</span>
            <span class=nx>targetInLeft</span> <span class=p>=</span> <span class=nx>target</span><span class=p>.</span><span class=nx>X</span> <span class=o>&lt;=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nx>X</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=nx>leftBox</span> <span class=p>=</span> <span class=nx>rectangle</span><span class=p>{</span><span class=nx>r</span><span class=p>.</span><span class=nx>min</span><span class=p>,</span> <span class=nx>Point</span><span class=p>{</span><span class=nx>r</span><span class=p>.</span><span class=nx>max</span><span class=p>.</span><span class=nx>X</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nx>Y</span><span class=p>}}</span>
            <span class=nx>rightBox</span> <span class=p>=</span> <span class=nx>rectangle</span><span class=p>{</span><span class=nx>Point</span><span class=p>{</span><span class=nx>r</span><span class=p>.</span><span class=nx>min</span><span class=p>.</span><span class=nx>X</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nx>Y</span><span class=p>},</span> <span class=nx>r</span><span class=p>.</span><span class=nx>max</span><span class=p>}</span>
            <span class=nx>targetInLeft</span> <span class=p>=</span> <span class=nx>target</span><span class=p>.</span><span class=nx>Y</span> <span class=o>&lt;=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nx>Y</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=nx>targetInLeft</span> <span class=p>{</span>
            <span class=nx>nearestNode</span><span class=p>,</span> <span class=nx>nearestBox</span> <span class=p>=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>left</span><span class=p>,</span> <span class=nx>leftBox</span>
            <span class=nx>furthestNode</span><span class=p>,</span> <span class=nx>furthestBox</span> <span class=p>=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>right</span><span class=p>,</span> <span class=nx>rightBox</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=nx>nearestNode</span><span class=p>,</span> <span class=nx>nearestBox</span> <span class=p>=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>right</span><span class=p>,</span> <span class=nx>rightBox</span>
            <span class=nx>furthestNode</span><span class=p>,</span> <span class=nx>furthestBox</span> <span class=p>=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>left</span><span class=p>,</span> <span class=nx>leftBox</span>
        <span class=p>}</span>

        <span class=nx>nearest</span><span class=p>,</span> <span class=nx>distSqd</span> <span class=p>=</span> <span class=nf>search</span><span class=p>(</span><span class=nx>nearestNode</span><span class=p>,</span> <span class=nx>target</span><span class=p>,</span> <span class=nx>nearestBox</span><span class=p>,</span> <span class=nx>maxDistSqd</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>distSqd</span> <span class=p>&lt;</span> <span class=nx>maxDistSqd</span> <span class=p>{</span>
            <span class=nx>maxDistSqd</span> <span class=p>=</span> <span class=nx>distSqd</span>
        <span class=p>}</span>

        <span class=kd>var</span> <span class=nx>d</span> <span class=kt>float64</span>
        <span class=k>if</span> <span class=nx>node</span><span class=p>.</span><span class=nx>splitByX</span> <span class=p>{</span>
            <span class=nx>d</span> <span class=p>=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nx>X</span> <span class=o>-</span> <span class=nx>target</span><span class=p>.</span><span class=nx>X</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=nx>d</span> <span class=p>=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nx>Y</span> <span class=o>-</span> <span class=nx>target</span><span class=p>.</span><span class=nx>Y</span>
        <span class=p>}</span>
        <span class=nx>d</span> <span class=o>*=</span> <span class=nx>d</span>

        <span class=k>if</span> <span class=nx>d</span> <span class=p>&gt;</span> <span class=nx>maxDistSqd</span> <span class=p>{</span>
            <span class=k>return</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=nx>d</span> <span class=p>=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>getDist</span><span class=p>(</span><span class=nx>target</span><span class=p>);</span> <span class=nx>d</span> <span class=p>&lt;</span> <span class=nx>distSqd</span> <span class=p>{</span>
            <span class=nx>nearest</span> <span class=p>=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>p</span>
            <span class=nx>distSqd</span> <span class=p>=</span> <span class=nx>d</span>
            <span class=nx>maxDistSqd</span> <span class=p>=</span> <span class=nx>distSqd</span>
        <span class=p>}</span>

        <span class=nx>tmpNearest</span><span class=p>,</span> <span class=nx>tmpSqd</span> <span class=o>:=</span> <span class=nf>search</span><span class=p>(</span><span class=nx>furthestNode</span><span class=p>,</span> <span class=nx>target</span><span class=p>,</span> <span class=nx>furthestBox</span><span class=p>,</span> <span class=nx>maxDistSqd</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>tmpSqd</span> <span class=p>&lt;</span> <span class=nx>distSqd</span> <span class=p>{</span>
            <span class=nx>nearest</span> <span class=p>=</span> <span class=nx>tmpNearest</span>
            <span class=nx>distSqd</span> <span class=p>=</span> <span class=nx>tmpSqd</span>
        <span class=p>}</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=nf>search</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>root</span><span class=p>,</span> <span class=nx>p</span><span class=p>,</span> <span class=nx>t</span><span class=p>.</span><span class=nx>bounds</span><span class=p>,</span> <span class=nx>math</span><span class=p>.</span><span class=nf>Inf</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></div><h2 id=point-relaxation>Point relaxation</h2>
<p>The last piece of the puzzle is implementing Lloyd&rsquo;s algorithm for relaxing the points obtained after importance sampling. First of all we are going to generate a 2D <a href=https://www.wikiwand.com/en/Probability_density_function>probability density function (PDF)</a> to determine the tone distribution on a given image. We will be using the PDF to &ldquo;weight&rdquo; the centroids calculations. Generating a PDF from an image is trivial.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>// A PDF is a probability density function.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>PDF</span> <span class=p>[][]</span><span class=kt>float64</span>

<span class=c1>// makePDF generates a probability density function from an image.Gray.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>MakePDF</span><span class=p>(</span><span class=nx>gray</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span><span class=p>)</span> <span class=nx>PDF</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=p>(</span>
        <span class=nx>bounds</span> <span class=p>=</span> <span class=nx>gray</span><span class=p>.</span><span class=nf>Bounds</span><span class=p>()</span>
        <span class=nx>pdf</span>    <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>PDF</span><span class=p>,</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dx</span><span class=p>())</span>
    <span class=p>)</span>
    <span class=k>for</span> <span class=nx>x</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>x</span> <span class=p>&lt;</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dx</span><span class=p>();</span> <span class=nx>x</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>pdf</span><span class=p>[</span><span class=nx>x</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>float64</span><span class=p>,</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dy</span><span class=p>())</span>
        <span class=k>for</span> <span class=nx>y</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>y</span> <span class=p>&lt;</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dy</span><span class=p>();</span> <span class=nx>y</span><span class=o>++</span> <span class=p>{</span>
            <span class=nx>pdf</span><span class=p>[</span><span class=nx>x</span><span class=p>][</span><span class=nx>y</span><span class=p>]</span> <span class=p>=</span> <span class=mi>255</span> <span class=o>-</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>gray</span><span class=p>.</span><span class=nf>GrayAt</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>).</span><span class=nx>Y</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>pdf</span>
<span class=p>}</span>
</code></pre></div><p>Our PDF is simply a 2D matrix where each cell corresponds to 255 minus the underlying gray intensity - so that darker values have higher values in the PDF. Usually a PDF has to sum up to 1 - this can be done by dividing each cell in the matrix by it&rsquo;s total sum - however for our purposes this isn&rsquo;t necessary.</p>
<p>We are going to be using three intermediate containers for storing information about the centroids.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=p>(</span>
    <span class=nx>siteCentroids</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=nx>Point</span><span class=p>]</span><span class=nx>Point</span><span class=p>)</span>
    <span class=nx>siteDensities</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=nx>Point</span><span class=p>]</span><span class=kt>float64</span><span class=p>)</span>
    <span class=nx>siteAreas</span>     <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=nx>Point</span><span class=p>]</span><span class=kt>float64</span><span class=p>)</span>
<span class=p>)</span>
</code></pre></div><p><code>siteCentroids</code> is going to map each site to it&rsquo;s centroid. The idea being that once the centroids are obtained they become the sites and new centroids can be calculated. <code>siteIntensities</code> is going to contain the total gray intensities associated to each site, which will be used for calculating the centroids and for adjusting the point sizes during rendering - I&rsquo;ll get to this later. For the moment let&rsquo;s look at the following piece of code.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>box</span><span class=p>.</span><span class=nx>min</span><span class=p>.</span><span class=nx>X</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>box</span><span class=p>.</span><span class=nx>max</span><span class=p>.</span><span class=nx>X</span><span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=nx>step</span> <span class=p>{</span>
    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>box</span><span class=p>.</span><span class=nx>min</span><span class=p>.</span><span class=nx>Y</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>box</span><span class=p>.</span><span class=nx>max</span><span class=p>.</span><span class=nx>Y</span><span class=p>;</span> <span class=nx>j</span> <span class=o>+=</span> <span class=nx>step</span> <span class=p>{</span>
        <span class=nx>p</span> <span class=o>:=</span> <span class=nx>Point</span><span class=p>{</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>}</span>
        <span class=nx>nn</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>kd</span><span class=p>.</span><span class=nf>findNearestNeighbour</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span>
        <span class=nx>w</span> <span class=o>:=</span> <span class=nx>pdf</span><span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=nx>i</span><span class=p>)][</span><span class=nb>int</span><span class=p>(</span><span class=nx>j</span><span class=p>)]</span>
        <span class=nx>centroid</span> <span class=o>:=</span> <span class=nx>siteCentroids</span><span class=p>[</span><span class=nx>nn</span><span class=p>]</span>
        <span class=nx>centroid</span><span class=p>.</span><span class=nx>X</span> <span class=o>+=</span> <span class=nx>w</span> <span class=o>*</span> <span class=nx>p</span><span class=p>.</span><span class=nx>X</span>
        <span class=nx>centroid</span><span class=p>.</span><span class=nx>Y</span> <span class=o>+=</span> <span class=nx>w</span> <span class=o>*</span> <span class=nx>p</span><span class=p>.</span><span class=nx>Y</span>
        <span class=nx>siteCentroids</span><span class=p>[</span><span class=nx>nn</span><span class=p>]</span> <span class=p>=</span> <span class=nx>centroid</span>
        <span class=nx>siteIntensities</span><span class=p>[</span><span class=nx>nn</span><span class=p>]</span> <span class=o>+=</span> <span class=nx>w</span>
        <span class=nx>siteNPoints</span><span class=p>[</span><span class=nx>nn</span><span class=p>]</span><span class=o>++</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>For calculating the centroids we have to calculate a weighted sum of each point contained in a Voronoi region. To do so I looped through each cell of the image, found it&rsquo;s closest site and then added the $x$ and $y$ coordinates to the matching centroid. In the previous snippet <code>box</code> is a <code>rectangle</code> which I defined earlier, I initialize one for generating the kd-tree associated to the input image bounds and the given sites.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=p>(</span>
    <span class=nx>box</span> <span class=p>=</span> <span class=nx>rectangle</span><span class=p>{</span>
        <span class=nx>Point</span><span class=p>{</span><span class=nb>float64</span><span class=p>(</span><span class=nx>bounds</span><span class=p>.</span><span class=nx>Min</span><span class=p>.</span><span class=nx>X</span><span class=p>),</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>bounds</span><span class=p>.</span><span class=nx>Min</span><span class=p>.</span><span class=nx>Y</span><span class=p>)},</span>
        <span class=nx>Point</span><span class=p>{</span><span class=nb>float64</span><span class=p>(</span><span class=nx>bounds</span><span class=p>.</span><span class=nx>Max</span><span class=p>.</span><span class=nx>X</span><span class=p>),</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>bounds</span><span class=p>.</span><span class=nx>Max</span><span class=p>.</span><span class=nx>Y</span><span class=p>)},</span>
    <span class=p>}</span>
    <span class=nx>kd</span> <span class=p>=</span> <span class=nf>makeKdTree</span><span class=p>(</span><span class=nx>sites</span><span class=p>,</span> <span class=nx>box</span><span class=p>)</span>
<span class=p>)</span>
</code></pre></div><p>At first I incremented <code>i</code> and <code>j</code>, this seemed but my final images were very blurry. It took me a fair amount of time to realize that I was lacking granularity and that Voronoi regions which were smaller than a pixel were getting overwritten. It&rsquo;s a bit difficult to understand but Adrian Secord mentions it in his paper, he refers to <a href=https://wwwx.cs.unc.edu/~geom/papers/documents/technicalreports/tr99011.pdf>this paper</a> for the solution. The trick is to <em>increase the virtual resolution</em> of the image and calculate the centroids with more points. I didn&rsquo;t find any implementations so maybe I&rsquo;m wrong but my understanding is that this means that we should increment <code>i</code> and <code>j</code> with a smaller step than 1. I chose to add a <code>resolution</code> parameter to my algorithm and I define <code>step</code> to be <code>1 / resolution</code>. This means that for a <code>resolution</code> value of 4 the algorithm iterates through $4^2 = 16$ more values than by default - the height and the width are each increased by 4. As I iterate through the image I also store the underlying PDF values and I count the number of points belonging to each site&rsquo;s region.</p>
<p>The function that we are building is going to return a list of centroids and a list of densities - both with the same size. The list of densities will be used to determine with which size each centroid should be drawn. Here is the code for doing the final calculation of the size of the centroids.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=p>(</span>
    <span class=nx>centroids</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Points</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>sites</span><span class=p>))</span>
    <span class=nx>densities</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>float64</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>sites</span><span class=p>))</span>
    <span class=nx>i</span>         <span class=kt>int</span>
<span class=p>)</span>

<span class=k>for</span> <span class=nx>site</span><span class=p>,</span> <span class=nx>density</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>siteIntensities</span> <span class=p>{</span>
    <span class=nx>centroid</span> <span class=o>:=</span> <span class=nx>siteCentroids</span><span class=p>[</span><span class=nx>site</span><span class=p>]</span>
    <span class=nx>centroid</span><span class=p>.</span><span class=nx>X</span> <span class=o>/=</span> <span class=nx>density</span>
    <span class=nx>centroid</span><span class=p>.</span><span class=nx>Y</span> <span class=o>/=</span> <span class=nx>density</span>
    <span class=nx>centroids</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>centroid</span>
    <span class=nx>densities</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>siteIntensities</span><span class=p>[</span><span class=nx>site</span><span class=p>]</span> <span class=o>/</span> <span class=nx>siteNPoints</span><span class=p>[</span><span class=nx>site</span><span class=p>]</span>
    <span class=nx>i</span><span class=o>++</span>
<span class=p>}</span>
</code></pre></div><p>In the previous snippet we were effectively calculating</p>
<p>$c_x = \sum_{p \in S} p(w) \times p(x)$</p>
<p>$c_y = \sum_{p \in S} p(w) \times p(y)$</p>
<p>$W = \sum_{p \in S} p(w)$</p>
<p>Now that we have $W$ we can divide $c_x$ and $c_y$ by it to obtain the final centroid values. All in all it&rsquo;s just a weighted average and it has to be calculated in two steps. Finally we &ldquo;empty&rdquo; the centroids and the densities into two slices before returning them. In Python this would have been automatic by calling a dict&rsquo;s <code>.values()</code> method.</p>
<h2 id=putting-it-all-together>Putting it all together</h2>
<p>We have finally gotten to the fun part where we can assemble all the concepts and algorithms we have seen and implemented. I made command-line program for running the algorithm - you can see the code <a href=https://github.com/MaxHalford/pointu/blob/master/cli.go>here</a>. The code is worth going into because it summarizes all the steps for producing stippled images:</p>
<ol>
<li>Open an image</li>
<li>Convert it to grayscale</li>
<li>Generate an initial set of points through importance sampling</li>
<li>Build the probability density function</li>
<li>Calculate the centroids a fixed number of times</li>
<li>Rescale the obtained densities between two fixed numbers to obtain radiuses</li>
<li>Draw each centroids with the obtained radiuses onto a new blank image</li>
<li>Save the generated image</li>
</ol>
<p>There are two values called <code>rMin</code> and <code>rMax</code> which determine the minimum and maximum point sizes which are obtained by rescaling the calculated densities. I also added the possibility to color the points based on the original image&rsquo;s colors, to do so I lookup the color at each centroid&rsquo;s coordinates.</p>
<p>Here is an example of running the algorithm with 12000 stippled with radiuses ranging from 0.3 to 2 after 30 iterations.</p>
<div align=center>
<figure style=width:80%>
<img src=/img/blog/halftoning-2/seurat.jpg alt=seurat>
<img src=/img/blog/halftoning-2/seurat_stippled.png alt=seurat_stippled>
<figcaption>Portraits are difficult to reproduce with pointillisme</figcaption>
</figure>
</div>
<p>In another fashion here is the penguin in my <a href=/blog/halftoning-1>previous blog post</a> stippled with 300 points of the same size. This doesn&rsquo;t look like much but the points outline the shape of the penguin quite well. This is a good candidate for reproducing <a href=http://www.cgl.uwaterloo.ca/csk/projects/tsp/>TSP art</a>, which I will be doing in another blog post, but not yet.</p>
<div align=center>
<figure style=width:80%>
<img src=/img/blog/halftoning-2/penguin_stippled.png alt=penguin_stippled>
<figcaption>I didn't forget you!</figcaption>
</figure>
</div>
<h2 id=conclusion>Conclusion</h2>
<p>It took me quite some time to nail down the details. At first I started manipulating integers and I couldn&rsquo;t figure out why my results were off. My &ldquo;breakthrough&rdquo; was to decompose the computation from the rendering, which with hindsight makes perfect sense. This is the whole idea of vector versus raster graphics. Using points with floating point coordinates for computation reduces rounding errors and allows to compute sub-pixel details.</p>
<p>I realize I went quickly through some of the details, this is simply because I didn&rsquo;t want to write a two-hour post. If you have questions or suggestions please feel free to contact me. As usual the code is <a href=https://github.com/MaxHalford/pointu>available on GitHub</a>.</p>
</div>
<script type=text/javascript>var s=document.createElement('script');s.setAttribute('src','https://utteranc.es/client.js'),s.setAttribute('repo','MaxHalford/maxhalford.github.io'),s.setAttribute('issue-term','pathname'),s.setAttribute('crossorigin','anonymous'),s.setAttribute('async',null),s.setAttribute('theme','github-light'),document.body.appendChild(s)</script>
<div class=footer>
<div class=do-the-thing>
<div class=elevator><svg class="sweet-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" enable-background="new 0 0 100 100" height="100" width="100"><path d="M70 47.5H30c-1.4.0-2.5 1.1-2.5 2.5v40c0 1.4 1.1 2.5 2.5 2.5h40c1.4.0 2.5-1.1 2.5-2.5V50C72.5 48.6 71.4 47.5 70 47.5zm-22.5 40h-5v-25h5v25zm10 0h-5v-25h5v25zm10 0h-5V60c0-1.4-1.1-2.5-2.5-2.5H40c-1.4.0-2.5 1.1-2.5 2.5v27.5h-5v-35h35v35z"/><path d="M50 42.5c1.4.0 2.5-1.1 2.5-2.5V16l5.7 5.7c.5.5 1.1.7 1.8.7s1.3-.2 1.8-.7c1-1 1-2.6.0-3.5l-10-10c-1-1-2.6-1-3.5.0l-10 10c-1 1-1 2.6.0 3.5 1 1 2.6 1 3.5.0l5.7-5.7v24c0 1.4 1.1 2.5 2.5 2.5z"/></svg>
Back to the top
</div>
</div>
</div>
<script src=https://cdnjs.cloudflare.com/ajax/libs/elevator.js/1.0.0/elevator.min.js></script>
<script>var elementButton=document.querySelector('.elevator'),elevator=new Elevator({element:elementButton,mainAudio:'/music/elevator.mp3',endAudio:'/music/ding.mp3'})</script>
<style>.down-arrow{font-size:120px;margin-top:90px;margin-bottom:90px;text-shadow:0 -20px #0c1f31,0 0 #c33329;color:transparent;-webkit-transform:scaleY(.8);-moz-transform:scaleY(.8);transform:scaleY(.8)}.elevator{text-align:center;cursor:pointer;width:140px;margin:auto}.elevator:hover{opacity:.7}.elevator svg{width:40px;height:40px;display:block;margin:auto;margin-bottom:5px}</style>
<div class=site-footer>
<div class=site-footer-item>
<a href=https://github.com/MaxHalford><span class=inline-svg><svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path fill="currentcolor" d="M8 0C3.58.0.0 3.582.0 8c0 3.535 2.292 6.533 5.47 7.59.4.075.547-.172.547-.385.0-.19-.007-.693-.01-1.36-2.226.483-2.695-1.073-2.695-1.073-.364-.924-.89-1.17-.89-1.17-.725-.496.056-.486.056-.486.803.056 1.225.824 1.225.824.714 1.223 1.873.87 2.33.665.072-.517.278-.87.507-1.07-1.777-.2-3.644-.888-3.644-3.953.0-.873.31-1.587.823-2.147-.09-.202-.36-1.015.07-2.117.0.0.67-.215 2.2.82.64-.178 1.32-.266 2-.27.68.004 1.36.092 2 .27 1.52-1.035 2.19-.82 2.19-.82.43 1.102.16 1.915.08 2.117.51.56.82 1.274.82 2.147.0 3.073-1.87 3.75-3.65 3.947.28.24.54.73.54 1.48.0 1.07-.01 1.93-.01 2.19.0.21.14.46.55.38C13.71 14.53 16 11.53 16 8c0-4.418-3.582-8-8-8"/></svg>
</span>
</a>
</div>
<div class=site-footer-item>
<a href=https://linkedin.com/in/maxhalford><span class=inline-svg><svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path fill="currentcolor" d="M13.632 13.635h-2.37V9.922c0-.886-.018-2.025-1.234-2.025-1.235.0-1.424.964-1.424 1.96v3.778h-2.37V6H8.51v1.04h.03c.318-.6 1.092-1.233 2.247-1.233 2.4.0 2.845 1.58 2.845 3.637v4.188zM3.558 4.955c-.762.0-1.376-.617-1.376-1.377.0-.758.614-1.375 1.376-1.375.76.0 1.376.617 1.376 1.375.0.76-.617 1.377-1.376 1.377zm1.188 8.68H2.37V6h2.376v7.635zM14.816.0H1.18C.528.0.0.516.0 1.153v13.694C0 15.484.528 16 1.18 16h13.635c.652.0 1.185-.516 1.185-1.153V1.153C16 .516 15.467.0 14.815.0z" fill-rule="nonzero"/></svg>
</span>
</a>
</div>
<div class=site-footer-item>
<a href=https://twitter.com/halford_max><span class=inline-svg><svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path fill="currentcolor" d="M16 3.038c-.59.26-1.22.437-1.885.517.677-.407 1.198-1.05 1.443-1.816-.634.37-1.337.64-2.085.79-.598-.64-1.45-1.04-2.396-1.04-1.812.0-3.282 1.47-3.282 3.28.0.26.03.51.085.75-2.728-.13-5.147-1.44-6.766-3.42C.83 2.58.67 3.14.67 3.75c0 1.14.58 2.143 1.46 2.732-.538-.017-1.045-.165-1.487-.41v.04c0 1.59 1.13 2.918 2.633 3.22-.276.074-.566.114-.865.114-.21.0-.41-.02-.61-.058.42 1.304 1.63 2.253 3.07 2.28-1.12.88-2.54 1.404-4.07 1.404-.26.0-.52-.015-.78-.045 1.46.93 3.18 1.474 5.04 1.474 6.04.0 9.34-5 9.34-9.33.0-.14.0-.28-.01-.42.64-.46 1.2-1.04 1.64-1.7z" fill-rule="nonzero"/></svg>
</span>
</a>
</div>
<div class=site-footer-item>
<a href=https://kaggle.com/maxhalford><span class=inline-svg><svg role="img" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><title>Kaggle icon</title><path fill="currentcolor" d="M18.825 23.859c-.022.092-.117.141-.281.141h-3.139c-.187.0-.351-.082-.492-.248l-5.178-6.589-1.448 1.374v5.111c0 .235-.117.352-.351.352H5.505c-.236.0-.354-.117-.354-.352V.353c0-.233.118-.353.354-.353h2.431c.234.0.351.12.351.353v14.343l6.203-6.272c.165-.165.33-.246.495-.246h3.239c.144.0.236.06.285.18.046.149.034.255-.036.315l-6.555 6.344 6.836 8.507c.095.104.117.208.07.358"/></svg>
</span>
</a>
</div>
<div class=site-footer-item>
<a href="https://scholar.google.com/citations?user=erRNNi0AAAAJ&hl=en"><span class=inline-svg><svg viewBox="0 0 1755 1755" xmlns="http://www.w3.org/2000/svg"><path fill="currentcolor" transform="translate(0 1610) scale(1 -1)" d="M896.76 1130.189c-27.618 30.838-59.618 46.19-95.802 46.19-40.952.0-72.382-14.738-94.288-44.15-21.906-29.322-32.864-64.848-32.864-106.584.0-35.548 5.998-71.738 18-108.64 11.958-36.886 31.524-69.814 58.954-98.838 27.334-29.096 59.144-43.616 95.284-43.616 40.288.0 71.76 13.502 94.332 40.492 22.476 26.954 33.756 60.98 33.756 101.962.0 34.904-5.954 71.454-17.906 109.664-11.894 38.262-31.752 72.784-59.466 103.52zm762.098 382.384c-64.358 64.424-141.86 96.57-232.572 96.57H329.144c-90.712.0-168.14-32.146-232.572-96.57-64.424-64.286-96.57-141.86-96.57-232.572V182.859c0-90.712 32.146-168.288 96.57-232.712 64.432-64.146 142-96.432 232.572-96.432h1097.142c90.712.0 168.214 32.286 232.572 96.57 64.432 64.432 96.644 141.86 96.644 232.572v1097.142c0 90.712-32.22 168.288-96.644 232.572zM1297.81 1154.159V762.033c0-18.154-14.856-33.016-33.016-33.016h-12.156c-18.162.0-33.016 14.856-33.016 33.016v392.126c0 16.12-2.34 29.578 20.188 32.41v52.172l-173.43-142.24c2.004-3.716 3.906-6.092 5.712-9.208 15.242-26.976 23.004-60.526 23.004-101.53.0-31.43-5.238-59.662-15.858-84.598-10.57-24.928-23.428-45.29-38.43-60.972-15.002-15.74-30.048-30.128-45.092-43.074-15.046-12.976-27.904-26.506-38.436-40.55-10.614-14-15.894-28.474-15.894-43.476.0-15.024 6.854-30.288 20.524-45.67 13.62-15.426 30.376-30.376 50.19-45.144 19.85-14.666 39.658-30.946 59.472-48.662 19.858-17.694 36.52-40.456 50.14-68.096 13.722-27.744 20.568-58.288 20.568-91.86.0-44.288-11.294-84.282-33.806-119.882-22.58-35.446-51.998-63.73-88.144-84.472-36.242-20.882-75-36.6-116.334-47.214-41.42-10.518-82.52-15.806-123.568-15.806-25.908.0-52.048 1.996-78.336 6.1-26.382 4.096-52.81 11.33-79.426 21.526-26.668 10.262-50.286 22.864-70.758 37.998-20.524 14.98-37.046 34.312-49.716 57.856-12.668 23.552-18.958 50.022-18.958 79.426.0 34.882 9.714 67.24 29.192 97.404 19.478 29.944 45.282 54.952 77.378 74.76 55.998 34.838 143.858 56.364 263.432 64.498-27.334 34.172-41.048 66.334-41.048 96.432.0 17.122 4.476 35.474 13.334 55.288-14.284-1.996-28.994-3.124-44.002-3.124-64.234.0-118.476 20.882-162.524 62.932-44.046 41.976-66.048 94.522-66.048 158.048.0 6.642.19 12.492.672 18.974H292.574l393.618 342.17h651.856l-60.24-47.024v-82.996c22.368-2.874 20.004-16.318 20.004-32.394zM900.382 544.929c-7.52 1.36-18.088 2.122-31.708 2.122-29.382.0-58.288-2.596-86.666-7.782-28.38-5.046-56.378-13.568-83.998-25.592-27.722-11.952-50.096-29.528-67.146-52.766-17.144-23.208-25.666-50.542-25.666-81.994.0-29.974 7.52-56.714 22.572-80.004 15.002-23.142 34.808-41.26 59.428-54.236 24.62-12.998 50.432-22.814 77.378-29.264 26.998-6.408 54.476-9.736 82.476-9.736 55.376.0 103.05 12.47 143.046 37.406 39.906 24.928 59.904 63.422 59.904 115.382.0 10.928-1.522 21.686-4.528 32.19-3.138 10.62-6.24 19.712-9.282 27.26-3.05 7.41-8.858 16.332-17.43 26.616-8.522 10.314-15.046 17.934-19.434 23.004-4.476 5.238-12.852 12.712-25.19 22.594-12.236 9.926-20.048 16.114-23.522 18.402-3.43 2.406-12.332 8.908-26.668 19.456-14.328 10.634-22.184 16.274-23.566 16.94z"/></svg>
</span>
</a>
</div>
<div class=site-footer-item>
<a href=/files/resume_max_halford.pdf><span class=inline-svg><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 392.533 392.533" style="enable-background:new 0 0 392.533 392.533"><g><g><path fill="currentcolor" d="M292.396 324.849H99.879c-6.012.0-10.925 4.848-10.925 10.925.0 6.012 4.849 10.925 10.925 10.925h192.582c6.012.0 10.925-4.849 10.925-10.925C303.321 329.697 298.473 324.849 292.396 324.849z"/></g></g><g><g><path fill="currentcolor" d="M292.396 277.01H99.879c-6.012.0-10.925 4.848-10.925 10.925.0 6.012 4.849 10.925 10.925 10.925h192.582c6.012.0 10.925-4.849 10.925-10.925C303.321 281.859 298.473 277.01 292.396 277.01z"/></g></g><g><g><path fill="currentcolor" d="M196.137 45.834c-25.859.0-46.998 21.075-46.998 46.998.0 25.859 21.139 46.933 46.998 46.933s46.998-21.075 46.998-46.998-21.139-46.933-46.998-46.933zm0 72.017c-13.77.0-25.083-11.313-25.083-25.083s11.248-25.083 25.083-25.083 25.083 11.313 25.083 25.083c0 13.769-11.313 25.083-25.083 25.083z"/></g></g><g><g><path fill="currentcolor" d="M258.521 163.362c-39.887-15.515-84.752-15.515-124.638.0-13.059 5.107-21.786 18.101-21.786 32.388v44.347c-.065 6.012 4.849 10.925 10.861 10.925h146.424c6.012.0 10.925-4.848 10.925-10.925V195.75C280.307 181.463 271.58 168.469 258.521 163.362zm0 65.874H133.883v-33.422c0-5.301 3.168-10.214 7.887-12.024 34.844-13.511 74.02-13.511 108.865.0 4.719 1.875 7.887 6.659 7.887 12.024v33.422z"/></g></g><g><g><path fill="currentcolor" d="M313.083.0H131.491c-8.404.0-16.291 3.232-22.238 9.18L57.018 61.414c-5.947 5.948-9.18 13.834-9.18 22.238v277.333c0 17.39 14.158 31.547 31.547 31.547h233.762c17.39.0 31.547-14.158 31.547-31.547V31.547C344.501 14.158 330.343.0 313.083.0zM112.032 37.236v27.022H85.01l27.022-27.022zm210.683 79.58h-40.598c-6.012.0-10.925 4.849-10.925 10.925.0 6.012 4.848 10.925 10.925 10.925h40.598v19.394h-14.869c-6.012.0-10.925 4.848-10.925 10.925.0 6.012 4.849 10.925 10.925 10.925h14.869v181.139c0 5.366-4.331 9.697-9.632 9.697H79.192c-5.301.0-9.632-4.331-9.632-9.632V86.044h53.398c6.012.0 10.925-4.848 10.925-10.925V21.721h179.2c5.301.0 9.632 4.331 9.632 9.632v85.463z"/></g></g><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/><g/></svg>
</span>
</a>
</div>
<div class=site-footer-item>
<a href=https://play.spotify.com/user/1166811350><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 168 168"><path fill="currentcolor" d="m83.996.277C37.747.277.253 37.77.253 84.019c0 46.251 37.494 83.741 83.743 83.741 46.254.0 83.744-37.49 83.744-83.741.0-46.246-37.49-83.738-83.745-83.738l.001-.004zm38.404 120.78c-1.5 2.46-4.72 3.24-7.18 1.73-19.662-12.01-44.414-14.73-73.564-8.07-2.809.64-5.609-1.12-6.249-3.93-.643-2.81 1.11-5.61 3.926-6.25 31.9-7.291 59.263-4.15 81.337 9.34 2.46 1.51 3.24 4.72 1.73 7.18zm10.25-22.805c-1.89 3.075-5.91 4.045-8.98 2.155-22.51-13.839-56.823-17.846-83.448-9.764-3.453 1.043-7.1-.903-8.148-4.35-1.04-3.453.907-7.093 4.354-8.143 30.413-9.228 68.222-4.758 94.072 11.127 3.07 1.89 4.04 5.91 2.15 8.976v-.001zm.88-23.744c-26.99-16.031-71.52-17.505-97.289-9.684-4.138 1.255-8.514-1.081-9.768-5.219-1.254-4.14 1.08-8.513 5.221-9.771 29.581-8.98 78.756-7.245 109.83 11.202 3.73 2.209 4.95 7.016 2.74 10.733-2.2 3.722-7.02 4.949-10.73 2.739z"/></svg>
</span>
</a>
</div>
<div class=site-footer-item>
<a href=mailto:maxhalford25@gmail.com><span class=inline-svg><svg viewBox="0 0 15 20" xmlns="http://www.w3.org/2000/svg"><title>mail</title><path fill="currentcolor" d="M0 4v8c0 .55.45 1 1 1h12c.55.0 1-.45 1-1V4c0-.55-.45-1-1-1H1c-.55.0-1 .45-1 1zm13 0L7 9 1 4h12zM1 5.5l4 3-4 3v-6zM2 12l3.5-3L7 10.5 8.5 9l3.5 3H2zm11-.5-4-3 4-3v6z" fill="#000" fill-rule="evenodd"/></svg>
</span>
</a>
</div>
<div class=site-footer-item>
<a href=/index.xml><span class=inline-svg><svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path fill="currentcolor" d="M12.8 16C12.8 8.978 7.022 3.2.0 3.2V0c8.777.0 16 7.223 16 16h-3.2zM2.194 11.61c1.21.0 2.195.985 2.195 2.196.0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017.0 13.806c0-1.21.983-2.195 2.194-2.195zM10.606 16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818.0 10.606 4.79 10.606 10.607z"/></svg>
</span>
</a>
</div>
</div>
<div style=margin-bottom:50px;display:flex;justify-content:center>
<iframe src=https://github.com/sponsors/MaxHalford/button title="Sponsor MaxHalford" height=35 width=116 style=border:0></iframe>
</div>
</div>
</div>
</article>
<script></script>
</body>
</html>