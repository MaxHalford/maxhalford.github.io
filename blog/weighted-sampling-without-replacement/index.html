<!doctype html><html lang=en><head><script defer src=https://unpkg.com/@tinybirdco/flock.js data-host=https://api.tinybird.co data-token=p.eyJ1IjogImMwMjJhMjg1LWJmY2YtNDc0OC1hYzczLTJhMDQ1Njk3NTI0YyIsICJpZCI6ICIzNjc3NjQ3Ny04MTE2LTRmYWQtYjcwMy1iZmM3YjMwZGJjMjMifQ.A0vHm-VWbXG6uBFZiwuspN_AyfSYNrdZE3IgwgWSt4g></script><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Max Halford"><meta property="og:url" content="https://maxhalford.github.io/blog/weighted-sampling-without-replacement/"><link rel=canonical href=https://maxhalford.github.io/blog/weighted-sampling-without-replacement/><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦”</text></svg>"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/maxhalford.github.io\/"},"articleSection":"blog","name":"Weighted sampling without replacement in pure Python","headline":"Weighted sampling without replacement in pure Python","description":"I\u0026rsquo;m working on a problem where I need to sample k items from a list without replacement. The sampling has to be weighted. In Python, numpy has random.choice method which allows doing this:\nimport numpy as np n = 10 k = 3 np.random.seed(42) population = np.arange(n) weights = np.random.dirichlet(np.ones_like(population)) np.random.choice(population, size=k, replace=False, p=weights) array([0, 9, 8]) I\u0026rsquo;m always wary of using numpy without thinking because I know it incurs some overhead.","inLanguage":"en-US","author":"Max Halford","creator":"Max Halford","publisher":"Max Halford","accountablePerson":"Max Halford","copyrightHolder":"Max Halford","copyrightYear":"2021","datePublished":"2021-12-24 00:00:00 \u002b0000 UTC","dateModified":"2021-12-24 00:00:00 \u002b0000 UTC","url":"https:\/\/maxhalford.github.io\/blog\/weighted-sampling-without-replacement\/","keywords":["python"]}</script><title>Weighted sampling without replacement in pure Python â€¢ Max Halford</title><meta property="og:title" content="Weighted sampling without replacement in pure Python â€¢ Max Halford"><meta property="og:type" content="article"><meta name=description content="I&rsquo;m working on a problem where I need to sample k items from a list without replacement. The sampling has to be weighted. In Python, numpy has random.choice method which allows doing this:
import numpy as np n = 10 k = 3 np.random.seed(42) population = np.arange(n) weights = np.random.dirichlet(np.ones_like(population)) np.random.choice(population, size=k, replace=False, p=weights) array([0, 9, 8]) I&rsquo;m always wary of using numpy without thinking because I know it incurs some overhead."><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/highlight/github.css><link rel=stylesheet href=/css/index.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Permanent+Marker&display=swap" rel=stylesheet><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><article class=post id=article><div class="row center-xs" style=text-align:left><div class="col-xs-12 col-sm-10 col-md-7 col-lg-5"><div class=header><header class=header-parts><div class="signatures site-title"><a href=/>Max Halford ðŸ¦”</a></div><div class=header-links><a class=header-link href=/>Blog</a>
<a class=header-link href=/links/>Links</a>
<a class=header-link href=/bio/>Bio</a></div></header></div><header class=post-header><h1 class=post-title>Weighted sampling without replacement in pure Python</h1><div class="row post-desc"><div class="col-xs-12 post-desc-items"><time class=post-date datetime="2021-12-24 00:00:00 UTC">2021-12-24</time>
<span class=posts-line-tag>python</span></div></div></header><div class="post-content markdown-body"><p>I&rsquo;m working on a problem where I need to sample <code>k</code> items from a list without replacement. The sampling has to be weighted. In Python, <code>numpy</code> has <code>random.choice</code> method which allows doing this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=n>k</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>seed</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>population</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>weights</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>dirichlet</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>ones_like</span><span class=p>(</span><span class=n>population</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>size</span><span class=o>=</span><span class=n>k</span><span class=p>,</span> <span class=n>replace</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>p</span><span class=o>=</span><span class=n>weights</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>array</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>8</span><span class=p>])</span>
</span></span></code></pre></div><p>I&rsquo;m always wary of using <code>numpy</code> without thinking because I know it incurs some overhead. This overhead is usually meaningful when small amounts of data are involved. In such a case, a pure Python implementation may be faster.</p><p>Python has a <a href=https://docs.python.org/3/library/random.html><code>random</code> module</a> in its standard library. This module provides a <a href=https://docs.python.org/3/library/random.html#random.choices><code>choices</code> function</a> to do random sampling. But this function doesn&rsquo;t support sampling without replacement.</p><p>I therefore set out to find a nice and simple algorithm to implement in pure Python. I knew that weighted sampling with replacement can be done with <a href=https://www.keithschwarz.com/darts-dice-coins/>Vose&rsquo;s alias method</a> &ndash; which I have implemented <a href=https://github.com/MaxHalford/vose>here</a> in Cython. I also knew that simple (non-weighted) sampling without replacement can be done with <a href=https://www.wikiwand.com/en/Reservoir_sampling>reservoir sampling</a>. But I&rsquo;d never looked into weighted sampling without replacement.</p><p>After some research, I found the algorithm of Efraimidis and Spirakis, which is succintely presented in section 3.2 of <a href=https://arxiv.org/pdf/1012.0256.pdf>this</a> paper. It&rsquo;s very simple, and from what I can tell it runs in $\mathcal{O}(nlog(n))$ time. Here is a Python implementation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>weighted_sample_without_replacement</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>rng</span><span class=o>=</span><span class=n>random</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span> <span class=o>=</span> <span class=p>[</span><span class=n>rng</span><span class=o>.</span><span class=n>random</span><span class=p>()</span> <span class=o>**</span> <span class=p>(</span><span class=mi>1</span> <span class=o>/</span> <span class=n>w</span><span class=p>)</span> <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=n>weights</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>order</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>population</span><span class=p>)),</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>i</span><span class=p>:</span> <span class=n>v</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>population</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>order</span><span class=p>[</span><span class=o>-</span><span class=n>k</span><span class=p>:]]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>rng</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>Random</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>weighted_sample_without_replacement</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>rng</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>[2, 0, 8]
</code></pre><p>Before worrying about speed, the first thing to check is if it&rsquo;s actually correct. We can do this by simulating many samples, tallying the results, and comparing those tallies to results from <code>numpy.random.choice</code>, as well as theoretical figures. Sadly I haven&rsquo;t found any closed-form expression that gives the probability of being sampled for each element. But those probabilities can be obtained with some deterministic code, provided you&rsquo;re confident.</p><details><summary>Click to see the code</summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>defaultdict</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>permutations</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>partial</span><span class=p>,</span> <span class=n>reduce</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>operator</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculate_theoretical_probas</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>product</span> <span class=o>=</span> <span class=n>partial</span><span class=p>(</span><span class=n>reduce</span><span class=p>,</span> <span class=n>operator</span><span class=o>.</span><span class=n>mul</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>P</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perm</span><span class=p>:</span> <span class=n>product</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>/</span> <span class=p>(</span><span class=nb>sum</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span> <span class=o>-</span> <span class=nb>sum</span><span class=p>(</span><span class=n>weights</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>perm</span><span class=p>[:</span><span class=n>step</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>step</span><span class=p>,</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>perm</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>perm</span> <span class=ow>in</span> <span class=n>permutations</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>P_per_element</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>float</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>perm</span><span class=p>,</span> <span class=n>p</span> <span class=ow>in</span> <span class=n>P</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>element</span> <span class=ow>in</span> <span class=n>perm</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>P_per_element</span><span class=p>[</span><span class=n>element</span><span class=p>]</span> <span class=o>+=</span> <span class=n>p</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>P_per_element</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>P</span> <span class=o>=</span> <span class=n>calculate_theoretical_probas</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;element&#39;</span><span class=p>,</span> <span class=s1>&#39;  weight&#39;</span><span class=p>,</span> <span class=s1>&#39;  P(sampled)&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>el</span> <span class=ow>in</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>P</span><span class=o>.</span><span class=n>keys</span><span class=p>(),</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>el</span><span class=p>:</span> <span class=n>P</span><span class=p>[</span><span class=n>el</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=n>el</span><span class=si>:</span><span class=s1>&gt;7</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=n>weights</span><span class=p>[</span><span class=n>el</span><span class=p>]</span><span class=si>:</span><span class=s1>&gt;8.2%</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=n>P</span><span class=p>[</span><span class=n>el</span><span class=p>]</span><span class=si>:</span><span class=s1>&gt;12.2%</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span></code></pre></div></details><pre tabindex=0><code>element   weight   P(sampled)
      6    0.58%        2.18%
      5    1.65%        6.12%
      4    1.65%        6.12%
      0    4.57%       16.40%
      3    8.89%       30.27%
      8    8.95%       30.45%
      9   11.99%       39.14%
      2   12.82%       41.35%
      7   19.58%       56.64%
      1   29.31%       71.32%
</code></pre><p>Now we can do a bar chart to compare these figures and see that our implementation is correct. I like this kind of eyeballing method. It doesn&rsquo;t replace a statistical test, but it&rsquo;s good enough for the purpose of a blog post.</p><details><summary>Click to see the code</summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>Counter</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>matplotlib.pyplot</span> <span class=k>as</span> <span class=nn>plt</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>repetitions</span> <span class=o>=</span> <span class=mi>10_000</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>counts_with_numpy</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>repetitions</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>sample</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>p</span><span class=o>=</span><span class=n>weights</span><span class=p>,</span> <span class=n>size</span><span class=o>=</span><span class=n>k</span><span class=p>,</span> <span class=n>replace</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>counts_with_numpy</span><span class=o>.</span><span class=n>update</span><span class=p>(</span><span class=n>sample</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>counts</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>repetitions</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>sample</span> <span class=o>=</span> <span class=n>weighted_sample_without_replacement</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>counts</span><span class=o>.</span><span class=n>update</span><span class=p>(</span><span class=n>sample</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>P</span> <span class=o>=</span> <span class=n>calculate_theoretical_probas</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=n>plt</span><span class=o>.</span><span class=n>xkcd</span><span class=p>():</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fig</span><span class=p>,</span> <span class=n>ax</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>7</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>width</span> <span class=o>=</span> <span class=mf>0.8</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ax</span><span class=o>.</span><span class=n>bar</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>label</span><span class=o>=</span><span class=s1>&#39;numpy&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span><span class=o>=</span><span class=p>[</span><span class=mi>5</span> <span class=o>*</span> <span class=n>p</span> <span class=o>-</span> <span class=n>width</span> <span class=o>*</span> <span class=mf>1.5</span> <span class=k>for</span> <span class=n>p</span> <span class=ow>in</span> <span class=n>population</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=n>height</span><span class=o>=</span><span class=p>[</span><span class=n>counts_with_numpy</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>population</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=n>width</span><span class=o>=</span><span class=n>width</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ax</span><span class=o>.</span><span class=n>bar</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>label</span><span class=o>=</span><span class=s1>&#39;Efraimidis and Spirakis&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span><span class=o>=</span><span class=p>[</span><span class=mi>5</span> <span class=o>*</span> <span class=n>p</span> <span class=k>for</span> <span class=n>p</span> <span class=ow>in</span> <span class=n>population</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=n>height</span><span class=o>=</span><span class=p>[</span><span class=n>counts</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>population</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=n>width</span><span class=o>=</span><span class=n>width</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ax</span><span class=o>.</span><span class=n>bar</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>label</span><span class=o>=</span><span class=s1>&#39;In theory&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span><span class=o>=</span><span class=p>[</span><span class=mi>5</span> <span class=o>*</span> <span class=n>p</span> <span class=o>+</span> <span class=n>width</span> <span class=o>*</span> <span class=mf>1.5</span> <span class=k>for</span> <span class=n>p</span> <span class=ow>in</span> <span class=n>population</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=n>height</span><span class=o>=</span><span class=p>[</span><span class=n>repetitions</span> <span class=o>*</span> <span class=n>P</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>population</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=n>width</span><span class=o>=</span><span class=n>width</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ax</span><span class=o>.</span><span class=n>set_xlabel</span><span class=p>(</span><span class=s1>&#39;Population&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ax</span><span class=o>.</span><span class=n>set_ylabel</span><span class=p>(</span><span class=s1>&#39;Times sampled&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>plt</span><span class=o>.</span><span class=n>xticks</span><span class=p>([</span><span class=mi>5</span> <span class=o>*</span> <span class=n>p</span> <span class=k>for</span> <span class=n>p</span> <span class=ow>in</span> <span class=n>population</span><span class=p>],</span> <span class=n>population</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ax</span><span class=o>.</span><span class=n>legend</span><span class=p>()</span>
</span></span></code></pre></div></details><p><img src=/img/blog/weighted-sampling-without-replacement/bar_chart.svg alt=bar_chart></p><p>Let&rsquo;s now concern ourselves with speed. I&rsquo;ve been sampling 3 elements from a list of length 10 in the above examples. Admittedly, those are small numbers. Let&rsquo;s see how this algorithm fairs against numpy.</p><p><strong>numpy.random.choice</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>%</span><span class=n>timeit</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>p</span><span class=o>=</span><span class=n>weights</span><span class=p>,</span> <span class=n>size</span><span class=o>=</span><span class=n>k</span><span class=p>,</span> <span class=n>replace</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>70.9 Âµs Â± 2.93 Âµs per loop (mean Â± std. dev. of 7 runs, 10000 loops each)
</code></pre><p><strong>Efraimidis and Spirakis</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>%</span><span class=n>timeit</span> <span class=n>weighted_sample_without_replacement</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>4.19 Âµs Â± 223 ns per loop (mean Â± std. dev. of 7 runs, 100000 loops each)
</code></pre><p>As you can see, the pure Python implementation is roughly 17 times faster. You might say that numpy is at a disavantage because it first has to cast the provided Python lists to numpy arrays. In fact that doesn&rsquo;t matter too much.</p><p><strong>numpy.random.choice with arrays</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>population_array</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>population</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>weights_array</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=n>timeit</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=n>population_array</span><span class=p>,</span> <span class=n>p</span><span class=o>=</span><span class=n>weights_array</span><span class=p>,</span> <span class=n>size</span><span class=o>=</span><span class=n>k</span><span class=p>,</span> <span class=n>replace</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>69.3 Âµs Â± 1.76 Âµs per loop (mean Â± std. dev. of 7 runs, 10000 loops each)
</code></pre><p>Naturally, numpy would beat the pure Python implementation if the list of elements were longer. It&rsquo;s losing here because it incurs too much overhead. There&rsquo;s actually a sweet spot after which numpy starts winning. We can find it visually by using the <a href=https://github.com/nschloe/perfplot><code>perfplot</code> library</a></p><details><summary>Click to see the code</summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>perfplot</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>k</span> <span class=o>=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=n>plt</span><span class=o>.</span><span class=n>xkcd</span><span class=p>():</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>out</span> <span class=o>=</span> <span class=n>perfplot</span><span class=o>.</span><span class=n>bench</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>setup</span><span class=o>=</span><span class=k>lambda</span> <span class=n>n</span><span class=p>:</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>population</span> <span class=o>:=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>))),</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>weights</span> <span class=o>:=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>dirichlet</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>ones_like</span><span class=p>(</span><span class=n>population</span><span class=p>))</span><span class=o>.</span><span class=n>tolist</span><span class=p>()),</span>
</span></span><span class=line><span class=cl>            <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>population</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>kernels</span><span class=o>=</span><span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=k>lambda</span> <span class=n>params</span><span class=p>:</span> <span class=n>weighted_sample_without_replacement</span><span class=p>(</span><span class=n>params</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>params</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>k</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=k>lambda</span> <span class=n>params</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=n>params</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>p</span><span class=o>=</span><span class=n>params</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>size</span><span class=o>=</span><span class=n>k</span><span class=p>,</span> <span class=n>replace</span><span class=o>=</span><span class=kc>False</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=k>lambda</span> <span class=n>params</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=n>params</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>p</span><span class=o>=</span><span class=n>params</span><span class=p>[</span><span class=mi>3</span><span class=p>],</span> <span class=n>size</span><span class=o>=</span><span class=n>k</span><span class=p>,</span> <span class=n>replace</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=n>labels</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;Efraimidis and Spirakis&#39;</span><span class=p>,</span> <span class=s1>&#39;numpy_without_array&#39;</span><span class=p>,</span> <span class=s1>&#39;numpy_with_array&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=n>n_range</span><span class=o>=</span><span class=p>[</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>200</span><span class=p>,</span> <span class=mi>300</span><span class=p>,</span> <span class=mi>500</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=n>xlabel</span><span class=o>=</span><span class=s1>&#39;n&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>equality_check</span><span class=o>=</span><span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>out</span><span class=o>.</span><span class=n>save</span><span class=p>(</span><span class=s1>&#39;perfplot.svg&#39;</span><span class=p>,</span> <span class=n>time_unit</span><span class=o>=</span><span class=s1>&#39;auto&#39;</span><span class=p>)</span>
</span></span></code></pre></div></details><p><img src=/img/blog/weighted-sampling-without-replacement/perfplot.svg alt=perfplot></p><p>This is a nice example of the trade-off when using numpy. The takeaway is that numpy isn&rsquo;t always better. It always depends on how much data is involved.</p><p>So there you go. I hope this post was useful to you. I&rsquo;m going back to enjoying X-mas.</p></div><script type=text/javascript>var s=document.createElement("script");s.setAttribute("src","https://utteranc.es/client.js"),s.setAttribute("repo","MaxHalford/maxhalford.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",null),s.setAttribute("theme","github-light"),document.body.appendChild(s)</script><div style=display:flex;flex-direction:row;justify-content:center;align-items:center;gap:20px;margin-bottom:30px><div class=do-the-thing><div class=elevator><svg class="sweet-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" enable-background="new 0 0 100 100" height="100" width="100"><path d="M70 47.5H30c-1.4.0-2.5 1.1-2.5 2.5v40c0 1.4 1.1 2.5 2.5 2.5h40c1.4.0 2.5-1.1 2.5-2.5V50C72.5 48.6 71.4 47.5 70 47.5zm-22.5 40h-5v-25h5v25zm10 0h-5v-25h5v25zm10 0h-5V60c0-1.4-1.1-2.5-2.5-2.5H40c-1.4.0-2.5 1.1-2.5 2.5v27.5h-5v-35h35v35z"/><path d="M50 42.5c1.4.0 2.5-1.1 2.5-2.5V16l5.7 5.7c.5.5 1.1.7 1.8.7s1.3-.2 1.8-.7c1-1 1-2.6.0-3.5l-10-10c-1-1-2.6-1-3.5.0l-10 10c-1 1-1 2.6.0 3.5 1 1 2.6 1 3.5.0l5.7-5.7v24c0 1.4 1.1 2.5 2.5 2.5z"/></svg>Back to the top</div></div><iframe src=https://github.com/sponsors/MaxHalford/button title="Sponsor MaxHalford" height=32 width=114 style=border:0;border-radius:6px></iframe></div><script src=https://cdnjs.cloudflare.com/ajax/libs/elevator.js/1.0.1/elevator.min.js></script>
<script>var elementButton=document.querySelector(".elevator"),elevator=new Elevator({element:elementButton,mainAudio:"/music/elevator.mp3",endAudio:"/music/ding.mp3"})</script><style>.down-arrow{font-size:120px;margin-top:90px;margin-bottom:90px;text-shadow:0 -20px #0c1f31,0 0 #c33329;color:transparent;-webkit-transform:scaleY(.8);-moz-transform:scaleY(.8);transform:scaleY(.8)}.elevator{text-align:center;cursor:pointer;width:140px;margin:auto}.elevator:hover{opacity:.7}.elevator svg{width:40px;height:40px;display:block;margin:auto;margin-bottom:5px}</style></div></div></article><script></script></body></html>