<!doctype html><html lang=en><head><script defer src=https://unpkg.com/@tinybirdco/flock.js data-host=https://api.tinybird.co data-token=p.eyJ1IjogImMwMjJhMjg1LWJmY2YtNDc0OC1hYzczLTJhMDQ1Njk3NTI0YyIsICJpZCI6ICIzNjc3NjQ3Ny04MTE2LTRmYWQtYjcwMy1iZmM3YjMwZGJjMjMifQ.A0vHm-VWbXG6uBFZiwuspN_AyfSYNrdZE3IgwgWSt4g></script><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Max Halford"><meta property="og:url" content="https://maxhalford.github.io/blog/halftoning-1/"><link rel=canonical href=https://maxhalford.github.io/blog/halftoning-1/><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦”</text></svg>"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/maxhalford.github.io\/"},"articleSection":"blog","name":"Halftoning with Go - Part 1","headline":"Halftoning with Go - Part 1","description":"Recently I stumbled upon this webpage which shows how to use a TSP solver as a halftoning technique. I began to read about related concepts like dithering and stippling. I don\u0026rsquo;t have any background in photography but I can appreciate the visual appeal of these techniques. As I understand it these techniques were first invented to save ink for printing. However nowadays printing has become cheaper and the modern use of these technique is mostly aesthetic, at least for images.","inLanguage":"en-US","author":"Max Halford","creator":"Max Halford","publisher":"Max Halford","accountablePerson":"Max Halford","copyrightHolder":"Max Halford","copyrightYear":"2016","datePublished":"2016-11-27 00:00:00 \u002b0000 UTC","dateModified":"2016-11-27 00:00:00 \u002b0000 UTC","url":"https:\/\/maxhalford.github.io\/blog\/halftoning-1\/","keywords":["image-processing"]}</script><title>Halftoning with Go - Part 1 â€¢ Max Halford</title><meta property="og:title" content="Halftoning with Go - Part 1 â€¢ Max Halford"><meta property="og:type" content="article"><meta name=description content="Recently I stumbled upon this webpage which shows how to use a TSP solver as a halftoning technique. I began to read about related concepts like dithering and stippling. I don&rsquo;t have any background in photography but I can appreciate the visual appeal of these techniques. As I understand it these techniques were first invented to save ink for printing. However nowadays printing has become cheaper and the modern use of these technique is mostly aesthetic, at least for images."><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/highlight/github.css><link rel=stylesheet href=/css/index.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Permanent+Marker&display=swap" rel=stylesheet><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><article class=post id=article><div class="row center-xs" style=text-align:left><div class="col-xs-12 col-sm-10 col-md-7 col-lg-5"><div class=header><header class=header-parts><div class="signatures site-title"><a href=/>Max Halford ðŸ¦”</a></div><div class=header-links><a class=header-link href=/>Blog</a>
<a class=header-link href=/links/>Links</a>
<a class=header-link href=/bio/>Bio</a></div></header></div><header class=post-header><h1 class=post-title>Halftoning with Go - Part 1</h1><div class="row post-desc"><div class="col-xs-12 post-desc-items"><time class=post-date datetime="2016-11-27 00:00:00 UTC">2016-11-27</time>
<span class=posts-line-tag>image-processing</span></div></div></header><div class="post-content markdown-body"><p>Recently I stumbled upon <a href=http://www.cgl.uwaterloo.ca/csk/projects/tsp/>this webpage</a> which shows how to use a TSP solver as a <a href=https://www.wikiwand.com/en/Halftone><em>halftoning</em></a> technique. I began to read about related concepts like <a href=https://www.wikiwand.com/en/Dither><em>dithering</em></a> and <a href=https://www.wikiwand.com/en/Stippling><em>stippling</em></a>. I don&rsquo;t have any background in photography but I can appreciate the visual appeal of these techniques. As I understand it these techniques were first invented to save ink for printing. However nowadays printing has become cheaper and the modern use of these technique is mostly aesthetic, at least for images.</p><div align=center><figure style=width:80%><img src=/img/blog/halftoning-1/pears.jpg alt=pears><figcaption>Look at those pears!</figcaption></figure></div><p>Before implementing a strong TSP solver to produce similar images than the ones shown in the webpage, I want to implement some simpler halftoning methods to get a feel for the field.</p><p>I will be doing this in Go and will be using the following image to compare the output of each method. For the sake of simplicity I will only look into black and white halftoning.</p><div align=center><figure style=width:80%><img src=/img/blog/halftoning-1/penguin.jpg alt=penguin><figcaption>I should give him a punny name</figcaption></figure></div><h2 id=average-dithering>Average dithering</h2><p><em>Average dithering</em> - also called <em>thresholding</em> - is the simplest dithering algorithm one may think of. The idea is to compare each pixel in a grayscale image to a threshold and to turn to the pixel to black or white based on it&rsquo;s intensity.</p><p>First and foremost, let&rsquo;s write down some code to open an image.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>loadImage</span><span class=p>(</span><span class=nx>filepath</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>image</span><span class=p>.</span><span class=nx>Image</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>infile</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=nx>filepath</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>infile</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>img</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>image</span><span class=p>.</span><span class=nf>Decode</span><span class=p>(</span><span class=nx>infile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>img</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Go does some magic with <code>image.Decode(infile)</code> to determine if the file is a PNG, a JPEG etc. It works fine as long as you register the format by importing the right package:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kn>import</span> <span class=nx>_</span> <span class=s>&#34;image/png&#34;</span>
</span></span></code></pre></div><p>This is quite well explained the <a href=https://golang.org/pkg/image/><code>image</code> package overview</a>.</p><p>Now let&rsquo;s write a function to convert a colored image to a grayscale one. The previous function opens a file and interprets it as an image with RGBA values ranging from 0 to 255. The <code>image</code> package provides a struct called <code>image.Gray</code> where each pixel is determined by a single value ranging from 0 to 255 representing how black (0) or white (255) the pixel is. The <code>image.Gray</code> struct provides a handy method called <code>Set(x, y, c)</code> which, well, sets a pixel located at <code>(x, y)</code> to a given RGBA color <code>c</code>. The method will take care of converting the provided RGBA color to an intensity of gray for us.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>rgbaToGray</span><span class=p>(</span><span class=nx>img</span> <span class=nx>image</span><span class=p>.</span><span class=nx>Image</span><span class=p>)</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nx>bounds</span> <span class=p>=</span> <span class=nx>img</span><span class=p>.</span><span class=nf>Bounds</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>gray</span>   <span class=p>=</span> <span class=nx>image</span><span class=p>.</span><span class=nf>NewGray</span><span class=p>(</span><span class=nx>bounds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>x</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>x</span> <span class=p>&lt;</span> <span class=nx>bounds</span><span class=p>.</span><span class=nx>Max</span><span class=p>.</span><span class=nx>X</span><span class=p>;</span> <span class=nx>x</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>y</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>y</span> <span class=p>&lt;</span> <span class=nx>bounds</span><span class=p>.</span><span class=nx>Max</span><span class=p>.</span><span class=nx>Y</span><span class=p>;</span> <span class=nx>y</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>var</span> <span class=nx>rgba</span> <span class=p>=</span> <span class=nx>img</span><span class=p>.</span><span class=nf>At</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>gray</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>rgba</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>gray</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Let&rsquo;s try this out!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>img</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nf>loadImage</span><span class=p>(</span><span class=s>&#34;penguin.jpg&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>gray</span> <span class=p>=</span> <span class=nf>rgbaToGray</span><span class=p>(</span><span class=nx>img</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Save as gray.png
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>f</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;gray.png&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>png</span><span class=p>.</span><span class=nf>Encode</span><span class=p>(</span><span class=nx>f</span><span class=p>,</span> <span class=nx>gray</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div align=center><figure style=width:80%><img src=/img/blog/halftoning-1/gray.png alt=grayscale><figcaption>The image is now a grayscale one</figcaption></figure></div><p>We are also going to need to write a function to round a grayscale color to black or white. I&rsquo;m doing with the benefit of hindsight; it is going to be a common operation and thus creating a separate function will spare us some lines of code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>blackOrWhite</span><span class=p>(</span><span class=nx>g</span> <span class=nx>color</span><span class=p>.</span><span class=nx>Gray</span><span class=p>)</span> <span class=nx>color</span><span class=p>.</span><span class=nx>Gray</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>g</span><span class=p>.</span><span class=nx>Y</span> <span class=p>&lt;</span> <span class=mi>127</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>color</span><span class=p>.</span><span class=nx>Gray</span><span class=p>{</span><span class=mi>0</span><span class=p>}</span> <span class=c1>// Black
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>color</span><span class=p>.</span><span class=nx>Gray</span><span class=p>{</span><span class=mi>255</span><span class=p>}</span> <span class=c1>// White
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Finally we are going to need a method for producing empty white images so that they can be written over.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>newWhite</span><span class=p>(</span><span class=nx>bounds</span> <span class=nx>image</span><span class=p>.</span><span class=nx>Rectangle</span><span class=p>)</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>white</span> <span class=p>=</span> <span class=nx>image</span><span class=p>.</span><span class=nf>NewGray</span><span class=p>(</span><span class=nx>bounds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>white</span><span class=p>.</span><span class=nx>Pix</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>white</span><span class=p>.</span><span class=nx>Pix</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=mi>255</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>white</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now that the basics are out of the way, we can get into the thick of it. Threshold dithering is very simple; indeed we only have to iterate through each pixel and compare it&rsquo;s intensity to a threshold between 0 and 255. In Go the grayscale values are the <code>uint8</code> type, meaning that they are unsigned ints written with 8 bits, thus our threshold value shall also be a <code>uint8</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ThresholdDither</span><span class=p>(</span><span class=nx>gray</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span><span class=p>)</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nx>bounds</span>   <span class=p>=</span> <span class=nx>gray</span><span class=p>.</span><span class=nf>Bounds</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>dithered</span> <span class=p>=</span> <span class=nx>image</span><span class=p>.</span><span class=nf>NewGray</span><span class=p>(</span><span class=nx>bounds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>width</span>    <span class=p>=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dx</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>height</span>   <span class=p>=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>width</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>height</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>var</span> <span class=nx>c</span> <span class=p>=</span> <span class=nf>blackOrWhite</span><span class=p>(</span><span class=nx>gray</span><span class=p>.</span><span class=nf>GrayAt</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nx>dithered</span><span class=p>.</span><span class=nf>SetGray</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>dithered</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Let&rsquo;s see what we obtain.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>img</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nf>loadImage</span><span class=p>(</span><span class=s>&#34;penguin.jpg&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>gray</span> <span class=p>=</span> <span class=nf>rgbaToGray</span><span class=p>(</span><span class=nx>img</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>dithered</span> <span class=p>=</span> <span class=nf>ThresholdDither</span><span class=p>(</span><span class=nx>gray</span><span class=p>,</span> <span class=mi>122</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>f</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;dithered.png&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>png</span><span class=p>.</span><span class=nf>Encode</span><span class=p>(</span><span class=nx>f</span><span class=p>,</span> <span class=nx>dithered</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div align=center><figure style=width:80%><img src=/img/blog/halftoning-1/threshold.png alt=threshold><figcaption>See how the tip of the nose is darker than the rest of it?</figcaption></figure></div><h2 id=grid-distribution>Grid distribution</h2><h3 id=overview>Overview</h3><p>The resulting image from threshold dithering puts big patches of black when a lot of close pixels are dark. The dithering process doesn&rsquo;t take into account the neighborhood of each pixel. For example turning a few pixels in a black patch to white would convey the same information whilst requiring less ink. This intuition is the basis of most halftoning techniques.</p><p>When Bosch and Herman published their &ldquo;TSP art&rdquo; paper in 2005, they proposed an algorithm for generating points that ressembles the original grayscale image. The points are produced based on the density of image - more black dots are generated in darker regions of the image - however not <em>too many</em> dots are produced. As we will see this method doesn&rsquo;t produce great images and thus it doesn&rsquo;t have any proper name in the literature, it&rsquo;s simply called &ldquo;Bosch and Hermanâ€™s grid-based method&rdquo;. The method requires performing the following steps:</p><h4 id=1-split-the-image-in-a-grid-of-cells-of-size-k>1. Split the image in a grid of cells of size $$k$$</h4><div align=center><figure style=width:80%><img src=/img/blog/halftoning-1/grid_1.png alt=grid_1><figcaption>The cells are of equal width and height</figcaption></figure></div><p>It is easy to see that the number of cells $C$ in the grid is</p><p>$$C = \frac{height}{k} \times \frac{width}{k}$$</p><p>If the width and the height of the image is not a multiple of $k$, then the cells at the bottom and the right will be cutoff. In this case cells on the right side be will be of width $width \bmod k$; similarly the height of the cells on the bottom side will be $height \bmod k$.</p><h4 id=2-calculate-the-average-darkness-in-each-cell>2. Calculate the average darkness in each cell</h4><div align=center><figure style=width:80%><img src=/img/blog/halftoning-1/grid_2.png alt=grid_2><figcaption>The darker the cell, the higher the ratio</figcaption></figure></div><p>We want to know <em>how dark is a cell</em>. The reason why will be clear in step 3. To do so we can simply calculate the average gray intensity and divide it by 256. This way we obtain a ratio $\mu$ &ndash; this is how it is denoted in the paper &ndash; with $\mu \in [0, 1]$. Mathematically, for each cell $c_{i,j}$ we will create an associated $\mu_{i,j}$ which is</p><p>$$\mu_{i,j} = \frac{1}{256k^2} \times \sum_{m=ik}^{ik+k} \sum_{n=jk}^{jk+k} I_{m,n}$$</p><p>where $I$ is the matrix containing the pixel intensities of the grayscale image. Of course the formula would be slightly less elegant if we were to take into account the squares on the right and on the bottom that are cut off. Regardless, the previous equation is just a fancy way of representing two simple for loops; as can be seen in the following snippet. The only thing to remember is that the closer each $\mu_{i,j}$ is to 0, the darker the matching cell is.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>avgIntensity</span><span class=p>(</span><span class=nx>gray</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span><span class=p>)</span> <span class=kt>float64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>sum</span> <span class=kt>float64</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>pix</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>gray</span><span class=p>.</span><span class=nx>Pix</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>sum</span> <span class=o>+=</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>pix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>sum</span> <span class=o>/</span> <span class=nb>float64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>gray</span><span class=p>.</span><span class=nx>Pix</span><span class=p>)</span><span class=o>*</span><span class=mi>256</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=3-sample-points-in-each-cell-based-on-the-cells-density>3. Sample points in each cell based on the cell&rsquo;s density</h4><p>Based on each cell&rsquo;s density, we want to place a number $n$ of black pixels into a new cell. Denser cells will produce more points whereas empty will produce less. Bosch and Herman proposed the following formula for determining $n$:</p><p>$$n = (1-\mu) \times \gamma$$</p><p>where $\gamma$ is the maximum of number of black points to sample.</p><h3 id=implementation>Implementation</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>GridDither</span><span class=p>(</span><span class=nx>gray</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span><span class=p>,</span> <span class=nx>k</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>gamma</span> <span class=kt>float64</span><span class=p>)</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nx>bounds</span>   <span class=p>=</span> <span class=nx>gray</span><span class=p>.</span><span class=nf>Bounds</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>dithered</span> <span class=p>=</span> <span class=nf>newWhite</span><span class=p>(</span><span class=nx>bounds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>width</span>    <span class=p>=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dx</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>height</span>   <span class=p>=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>rng</span>      <span class=p>=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>NewSource</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>width</span><span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=nx>k</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>height</span><span class=p>;</span> <span class=nx>j</span> <span class=o>+=</span> <span class=nx>k</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nx>cell</span> <span class=p>=</span> <span class=nf>rgbaToGray</span><span class=p>(</span><span class=nx>gray</span><span class=p>.</span><span class=nf>SubImage</span><span class=p>(</span><span class=nx>image</span><span class=p>.</span><span class=nf>Rect</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>i</span><span class=o>+</span><span class=nx>k</span><span class=p>,</span> <span class=nx>j</span><span class=o>+</span><span class=nx>k</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                <span class=nx>mu</span>   <span class=p>=</span> <span class=nf>avgIntensity</span><span class=p>(</span><span class=nx>cell</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nx>n</span>    <span class=p>=</span> <span class=p>(</span><span class=mi>1</span><span class=o>-</span><span class=nx>mu</span><span class=p>)</span><span class=o>*</span><span class=nx>gamma</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=nx>k</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>k</span> <span class=p>&lt;</span> <span class=nb>int</span><span class=p>(</span><span class=nx>n</span><span class=p>);</span> <span class=nx>k</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=nx>x</span> <span class=p>=</span> <span class=nf>randInt</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nf>min</span><span class=p>(</span><span class=nx>i</span><span class=o>+</span><span class=nx>k</span><span class=p>,</span> <span class=nx>width</span><span class=p>),</span> <span class=nx>rng</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=nx>y</span> <span class=p>=</span> <span class=nf>randInt</span><span class=p>(</span><span class=nx>j</span><span class=p>,</span> <span class=nf>min</span><span class=p>(</span><span class=nx>j</span><span class=o>+</span><span class=nx>k</span><span class=p>,</span> <span class=nx>height</span><span class=p>),</span> <span class=nx>rng</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nx>dithered</span><span class=p>.</span><span class=nf>SetGray</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>color</span><span class=p>.</span><span class=nx>Gray</span><span class=p>{</span><span class=mi>0</span><span class=p>})</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>dithered</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>randInt(min, max)</code> is a custom method for generating a random number in range $[min, max)$.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>randInt</span><span class=p>(</span><span class=nx>min</span><span class=p>,</span> <span class=nx>max</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>rng</span> <span class=o>*</span><span class=nx>rand</span><span class=p>.</span><span class=nx>Rand</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>rng</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=nx>max</span><span class=o>-</span><span class=nx>min</span><span class=p>)</span> <span class=o>+</span> <span class=nx>min</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Let&rsquo;s look at the output of the grid-based method for $k=5$ and $\gamma=8$ - usually picking a small $k$ works best.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>img</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nf>loadImage</span><span class=p>(</span><span class=s>&#34;penguin.jpg&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>gray</span> <span class=p>=</span> <span class=nf>rgbaToGray</span><span class=p>(</span><span class=nx>img</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>dithered</span> <span class=p>=</span> <span class=nf>GridDither</span><span class=p>(</span><span class=nx>gray</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>f</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;dithered.png&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>png</span><span class=p>.</span><span class=nf>Encode</span><span class=p>(</span><span class=nx>f</span><span class=p>,</span> <span class=nx>dithered</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div align=center><figure style=width:80%><img src=/img/blog/halftoning-1/grid_3.png alt=grid_3><figcaption>You can see the penguin if you squint</figcaption></figure></div><p>The penguin is recognizable, however there is a lot of &ldquo;noise&rdquo; on the left part of image. This is because although the cells are not very dark, there can still be a few blacks points that are sampled because there isn&rsquo;t any minimum bounds on $n$. What&rsquo;s more, it would be nice to add some contrast to the image to render more points in darker cells. Bosch and Herman proposed to amplify $n$ in the following way:</p><p>$$n = \frac{((1-\mu) \times \gamma)^2}{3}$$</p><p>The formula isn&rsquo;t magic, it just takes some tinkering to get right. Because we are working on results with visual appeal, there isn&rsquo;t really any theoretical background to justify these formulas. Practice makes perfect!</p><p>As for the minimum number of points, we can simply include an if condition and set $n$ to 0 if $n$ is lower than a threshold $\alpha$. The modified code is the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>GridDither</span><span class=p>(</span><span class=nx>gray</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span><span class=p>,</span> <span class=nx>k</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>alpha</span><span class=p>,</span> <span class=nx>gamma</span> <span class=kt>float64</span><span class=p>)</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nx>bounds</span>   <span class=p>=</span> <span class=nx>gray</span><span class=p>.</span><span class=nf>Bounds</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>dithered</span> <span class=p>=</span> <span class=nf>newWhite</span><span class=p>(</span><span class=nx>bounds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>width</span>    <span class=p>=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dx</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>height</span>   <span class=p>=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>rng</span>      <span class=p>=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>NewSource</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>width</span><span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=nx>k</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>height</span><span class=p>;</span> <span class=nx>j</span> <span class=o>+=</span> <span class=nx>k</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nx>cell</span> <span class=p>=</span> <span class=nf>rgbaToGray</span><span class=p>(</span><span class=nx>gray</span><span class=p>.</span><span class=nf>SubImage</span><span class=p>(</span><span class=nx>image</span><span class=p>.</span><span class=nf>Rect</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>i</span><span class=o>+</span><span class=nx>k</span><span class=p>,</span> <span class=nx>j</span><span class=o>+</span><span class=nx>k</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                <span class=nx>mu</span>   <span class=p>=</span> <span class=nf>avgIntensity</span><span class=p>(</span><span class=nx>cell</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nx>n</span>    <span class=p>=</span> <span class=nx>math</span><span class=p>.</span><span class=nf>Pow</span><span class=p>((</span><span class=mi>1</span><span class=o>-</span><span class=nx>mu</span><span class=p>)</span><span class=o>*</span><span class=nx>gamma</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=o>/</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=nx>alpha</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>n</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=nx>k</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>k</span> <span class=p>&lt;</span> <span class=nb>int</span><span class=p>(</span><span class=nx>n</span><span class=p>);</span> <span class=nx>k</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=nx>x</span> <span class=p>=</span> <span class=nf>randInt</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nf>min</span><span class=p>(</span><span class=nx>i</span><span class=o>+</span><span class=nx>k</span><span class=p>,</span> <span class=nx>width</span><span class=p>),</span> <span class=nx>rng</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=nx>y</span> <span class=p>=</span> <span class=nf>randInt</span><span class=p>(</span><span class=nx>j</span><span class=p>,</span> <span class=nf>min</span><span class=p>(</span><span class=nx>j</span><span class=o>+</span><span class=nx>k</span><span class=p>,</span> <span class=nx>height</span><span class=p>),</span> <span class=nx>rng</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nx>dithered</span><span class=p>.</span><span class=nf>SetGray</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>color</span><span class=p>.</span><span class=nx>Gray</span><span class=p>{</span><span class=mi>0</span><span class=p>})</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>dithered</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>With the same parameters ($k=5$ and $\gamma=8$) and $\alpha=3$ the following image is obtained.</p><div align=center><figure style=width:80%><img src=/img/blog/halftoning-1/grid_4.png alt=grid_4><figcaption>The snow is mostly how it should be, white</figcaption></figure></div><p>The result is a huge step forward. The same patches from threshold dithering are preserved, but they contain way less pixels. However we can&rsquo;t say that the image is very <em>appealing</em> in an artistic sense. For example there are not no continuous curves that seem to appear, nor are the black points evenly spaced. What&rsquo;s more, there are quite a few parameters to tweak, which isn&rsquo;t very practical if one wishes to build a generic halftoning method. Luckily there exist many more smarter algorithms for producing &ldquo;better&rdquo; halftoned images.</p><h2 id=floyd-steinberg-dithering>Floyd-Steinberg dithering</h2><p>Before talking about <a href=https://www.wikiwand.com/en/Floyd%E2%80%93Steinberg_dithering>Floyd-Steinberg dithering</a>, let&rsquo;s briefly delve into the concept of <em>error diffusion</em>. The issue with the previous methods is that when a pixel was set to black, this information was not taken into account when considering turning to black a neighboring pixel. With error diffusion, the idea is to &ldquo;carry&rdquo; the difference between a pixel&rsquo;s intensity and a threshold - this is called the <em>quantization error</em> - to the neighboring cells so as to reverse the turning into black or white decision. Admitedly this is still a vague concept, but it&rsquo;s worth understanding!</p><p>The easiest error diffusion method is simply to add the quantization error of a pixel to the next one when looping through the image. For example, say a pixel&rsquo;s intensity is 90 and the threshold is 120, then the pixel is turned to black because 90 is lower than 120; the quantization error is $90-0=90$. Then say that the next pixel has an intensity of 80. Instead of setting it to 0 because it is lower than 120, add the quantization error of the previous pixel and turn it to white because $80+90=170$ which is higher than 120. The quantization error of that pixel is then $170-255=-85$. This way turning a pixel to black will &ldquo;discourage&rdquo; the next pixel to be turned to black.</p><p>Algorithms such Floyd-Steinberg dithering use this principle and &ldquo;spread&rdquo; each pixel&rsquo;s quantization error following a certain pattern. This is quite well explained on the <a href=https://www.wikiwand.com/en/Error_diffusion>error diffusion Wikipedia article</a> so I&rsquo;m not going to explain it in detail. With the Floyd-Steinberg variant, the idea is to spread the quantization error in the following way:</p><pre><code>      X      7/16
3/16  5/16   1/16
</code></pre><p>At each pixel <code>X</code> the quantization error is split between the indicated neighbors for the indicated fraction. For example the pixel to the left of <code>X</code> will receive 7/16th of the quantization error. The fractions may seem arbitrary, but I can assure you that Floyd and Steinberg had their reasons for choosing. Regardless, let&rsquo;s implement this procedure.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>FloydSteinbergDither</span><span class=p>(</span><span class=nx>gray</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span><span class=p>)</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nx>bounds</span>   <span class=p>=</span> <span class=nx>gray</span><span class=p>.</span><span class=nf>Bounds</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>width</span>    <span class=p>=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dx</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>height</span>   <span class=p>=</span> <span class=nx>bounds</span><span class=p>.</span><span class=nf>Dy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>dithered</span> <span class=p>=</span> <span class=nf>copyGray</span><span class=p>(</span><span class=nx>gray</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>height</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// Top to bottom
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>width</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// Left to right
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kd>var</span> <span class=nx>oldPixel</span> <span class=p>=</span> <span class=nx>dithered</span><span class=p>.</span><span class=nf>GrayAt</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Set the pixel to black or white
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kd>var</span> <span class=nx>newPixel</span> <span class=p>=</span> <span class=nf>blackOrWhite</span><span class=p>(</span><span class=nx>oldPixel</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>dithered</span><span class=p>.</span><span class=nf>SetGray</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>newPixel</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Determine the quantization error
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kd>var</span> <span class=nx>quant</span> <span class=p>=</span> <span class=p>(</span><span class=nb>int16</span><span class=p>(</span><span class=nx>oldPixel</span><span class=p>.</span><span class=nx>Y</span><span class=p>)</span> <span class=o>-</span> <span class=nb>int16</span><span class=p>(</span><span class=nx>newPixel</span><span class=p>.</span><span class=nx>Y</span><span class=p>))</span> <span class=o>/</span> <span class=mi>16</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Right pixel
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>dithered</span><span class=p>.</span><span class=nf>SetGray</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>j</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>color</span><span class=p>.</span><span class=nx>Gray</span><span class=p>{</span><span class=nf>i16ToUI8</span><span class=p>(</span><span class=nb>int16</span><span class=p>(</span><span class=nx>dithered</span><span class=p>.</span><span class=nf>GrayAt</span><span class=p>(</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>j</span><span class=p>).</span><span class=nx>Y</span><span class=p>)</span> <span class=o>+</span> <span class=mi>7</span><span class=o>*</span><span class=nx>quant</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Bottom left pixel
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>dithered</span><span class=p>.</span><span class=nf>SetGray</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>color</span><span class=p>.</span><span class=nx>Gray</span><span class=p>{</span><span class=nf>i16ToUI8</span><span class=p>(</span><span class=nb>int16</span><span class=p>(</span><span class=nx>dithered</span><span class=p>.</span><span class=nf>GrayAt</span><span class=p>(</span><span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>).</span><span class=nx>Y</span><span class=p>)</span> <span class=o>+</span> <span class=mi>3</span><span class=o>*</span><span class=nx>quant</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Bottom pixel
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>dithered</span><span class=p>.</span><span class=nf>SetGray</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nx>i</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>color</span><span class=p>.</span><span class=nx>Gray</span><span class=p>{</span><span class=nf>i16ToUI8</span><span class=p>(</span><span class=nb>int16</span><span class=p>(</span><span class=nx>dithered</span><span class=p>.</span><span class=nf>GrayAt</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>).</span><span class=nx>Y</span><span class=p>)</span> <span class=o>+</span> <span class=mi>5</span><span class=o>*</span><span class=nx>quant</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Bottom right pixel
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>dithered</span><span class=p>.</span><span class=nf>SetGray</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>color</span><span class=p>.</span><span class=nx>Gray</span><span class=p>{</span><span class=nf>i16ToUI8</span><span class=p>(</span><span class=nb>int16</span><span class=p>(</span><span class=nx>dithered</span><span class=p>.</span><span class=nf>GrayAt</span><span class=p>(</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>).</span><span class=nx>Y</span><span class=p>)</span> <span class=o>+</span> <span class=nx>quant</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>dithered</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>image</code> and the <code>color</code> packages are not magic: types have to be modified explicitly in order to perform certain operations. Each pixel in a grayscale image is basically a <code>uint8</code>, which is an unsigned integer which can take values in $[0, 255]$. When the error is spread to the neigboring pixels, it&rsquo;s possible that the intensity of the pixel added to the error will overflow the receiving <code>uint8</code> variable. Thus I temporarily convert the intensity to <code>uint16</code> which won&rsquo;t overflow. Then I convert it back to a <code>uint8</code> but I take into account if the <code>uint16</code> is beyond the capacity of the <code>uint8</code>. For example in Go <code>uint8(-42)</code> returns $255 + (-42) = 214$. The function I use to overcome this little issue is quite simple:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>i16ToUI8</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int16</span><span class=p>)</span> <span class=kt>uint8</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>x</span> <span class=p>&lt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>uint8</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>x</span> <span class=p>&gt;</span> <span class=mi>254</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>uint8</span><span class=p>(</span><span class=mi>255</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>uint8</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>I also used a function to clone a grayscale image.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kd>func</span> <span class=nf>copyGray</span><span class=p>(</span><span class=nx>gray</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span><span class=p>)</span> <span class=o>*</span><span class=nx>image</span><span class=p>.</span><span class=nx>Gray</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>clone</span> <span class=p>=</span> <span class=nx>image</span><span class=p>.</span><span class=nf>NewGray</span><span class=p>(</span><span class=nx>gray</span><span class=p>.</span><span class=nf>Bounds</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nb>copy</span><span class=p>(</span><span class=nx>clone</span><span class=p>.</span><span class=nx>Pix</span><span class=p>,</span> <span class=nx>gray</span><span class=p>.</span><span class=nx>Pix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>clone</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Let&rsquo;s have a look at the result. I&rsquo;m not going to write the <code>main</code> function, it&rsquo;s getting a bit redundant.</p><div align=center><figure style=width:80%><img src=/img/blog/halftoning-1/floyd_steinberg.png alt=floyd_steinberg><figcaption>Pretty smooth!</figcaption></figure></div><p>The result from the Floyd-Steinberg seems more &ldquo;appealing&rdquo;. The penguin has sharper features and his fur is more distinguishable. Also if you look at the penguin&rsquo;s face you might notice how evenly spread the dots are. I find it oddly satisfying. There exist many more error diffusion algorithms that produce more or less similar images. For example some spread the quantization error to further pixels instead of just the adjacent ones.</p><h2 id=conclusion>Conclusion</h2><p>That wraps it up for this post! I hope you had a nice read. In the next blog post I&rsquo;ll be looking at a more advanced algorithm called <em>weighted centroidal VoronoÃ¯ diagrams</em>, which is a stippling technique.</p><p>If this post peaked your interest, have a look at <a href=http://www.efg2.com/Lab/Library/ImageProcessing/DHALF.TXT>this</a>, I thought it was quite an interesting read.</p><p>The code in this blog post is <a href=https://github.com/MaxHalford/halfgone/releases/tag/0.0.1>available on GitHub</a>. It&rsquo;s not exactly the same; for example I&rsquo;ve used an interface, but it&rsquo;s nothing complicated. Basically I&rsquo;m thinking of making a little package for halftoning in Go, I&rsquo;ll see how it goes.</p></div><script type=text/javascript>var s=document.createElement("script");s.setAttribute("src","https://utteranc.es/client.js"),s.setAttribute("repo","MaxHalford/maxhalford.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",null),s.setAttribute("theme","github-light"),document.body.appendChild(s)</script><div style=display:flex;flex-direction:row;justify-content:center;align-items:center;gap:20px;margin-bottom:30px><div class=do-the-thing><div class=elevator><svg class="sweet-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" enable-background="new 0 0 100 100" height="100" width="100"><path d="M70 47.5H30c-1.4.0-2.5 1.1-2.5 2.5v40c0 1.4 1.1 2.5 2.5 2.5h40c1.4.0 2.5-1.1 2.5-2.5V50C72.5 48.6 71.4 47.5 70 47.5zm-22.5 40h-5v-25h5v25zm10 0h-5v-25h5v25zm10 0h-5V60c0-1.4-1.1-2.5-2.5-2.5H40c-1.4.0-2.5 1.1-2.5 2.5v27.5h-5v-35h35v35z"/><path d="M50 42.5c1.4.0 2.5-1.1 2.5-2.5V16l5.7 5.7c.5.5 1.1.7 1.8.7s1.3-.2 1.8-.7c1-1 1-2.6.0-3.5l-10-10c-1-1-2.6-1-3.5.0l-10 10c-1 1-1 2.6.0 3.5 1 1 2.6 1 3.5.0l5.7-5.7v24c0 1.4 1.1 2.5 2.5 2.5z"/></svg>Back to the top</div></div><iframe src=https://github.com/sponsors/MaxHalford/button title="Sponsor MaxHalford" height=32 width=114 style=border:0;border-radius:6px></iframe></div><script src=https://cdnjs.cloudflare.com/ajax/libs/elevator.js/1.0.1/elevator.min.js></script>
<script>var elementButton=document.querySelector(".elevator"),elevator=new Elevator({element:elementButton,mainAudio:"/music/elevator.mp3",endAudio:"/music/ding.mp3"})</script><style>.down-arrow{font-size:120px;margin-top:90px;margin-bottom:90px;text-shadow:0 -20px #0c1f31,0 0 #c33329;color:transparent;-webkit-transform:scaleY(.8);-moz-transform:scaleY(.8);transform:scaleY(.8)}.elevator{text-align:center;cursor:pointer;width:140px;margin:auto}.elevator:hover{opacity:.7}.elevator svg{width:40px;height:40px;display:block;margin:auto;margin-bottom:5px}</style></div></div></article><script></script></body></html>