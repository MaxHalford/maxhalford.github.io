<!doctype html><html lang=en><head><script defer src=https://unpkg.com/@tinybirdco/flock.js data-host=https://api.tinybird.co data-token=p.eyJ1IjogImMwMjJhMjg1LWJmY2YtNDc0OC1hYzczLTJhMDQ1Njk3NTI0YyIsICJpZCI6ICIzNjc3NjQ3Ny04MTE2LTRmYWQtYjcwMy1iZmM3YjMwZGJjMjMifQ.A0vHm-VWbXG6uBFZiwuspN_AyfSYNrdZE3IgwgWSt4g></script><meta charset=utf-8><meta name=generator content="Hugo 0.121.1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Max Halford"><meta property="og:url" content="https://maxhalford.github.io/blog/graph-components-duckdb/"><link rel=canonical href=https://maxhalford.github.io/blog/graph-components-duckdb/><meta property="og:title" content="Graph components with DuckDB"><meta property="og:description" content="Introduction Graph problems are quite common. However, it&rsquo;s rare to have access to a database offering graph semantics. There are graph databases, such as Neo4j and GraphX, but it&rsquo;s difficult to justify setting one of those up. One could simply use networkx in Python. But that only works if the graph fits in memory.
From a practical angle, the fact is that people are querying data warehouses in SQL. There are many good reasons to write graph algorithms in SQL."><meta property="og:type" content="article"><meta property="og:url" content="https://maxhalford.github.io/blog/graph-components-duckdb/"><meta property="og:image" content="https://maxhalford.github.io/img/blog/graph-components-duckdb/cover.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-06-03T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-03T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://maxhalford.github.io/img/blog/graph-components-duckdb/cover.png"><meta name=twitter:title content="Graph components with DuckDB"><meta name=twitter:description content="Introduction Graph problems are quite common. However, it&rsquo;s rare to have access to a database offering graph semantics. There are graph databases, such as Neo4j and GraphX, but it&rsquo;s difficult to justify setting one of those up. One could simply use networkx in Python. But that only works if the graph fits in memory.
From a practical angle, the fact is that people are querying data warehouses in SQL. There are many good reasons to write graph algorithms in SQL."><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🦔</text></svg>"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/maxhalford.github.io\/"},"articleSection":"blog","name":"Graph components with DuckDB","headline":"Graph components with DuckDB","description":"Introduction Graph problems are quite common. However, it\u0026rsquo;s rare to have access to a database offering graph semantics. There are graph databases, such as Neo4j and GraphX, but it\u0026rsquo;s difficult to justify setting one of those up. One could simply use networkx in Python. But that only works if the graph fits in memory.\nFrom a practical angle, the fact is that people are querying data warehouses in SQL. There are many good reasons to write graph algorithms in SQL.","inLanguage":"en-US","author":"Max Halford","creator":"Max Halford","publisher":"Max Halford","accountablePerson":"Max Halford","copyrightHolder":"Max Halford","copyrightYear":"2023","datePublished":"2023-06-03 00:00:00 \u002b0000 UTC","dateModified":"2023-06-03 00:00:00 \u002b0000 UTC","url":"https:\/\/maxhalford.github.io\/blog\/graph-components-duckdb\/","keywords":["data-science","sql"]}</script><title>Graph components with DuckDB • Max Halford</title>
<meta property="og:title" content="Graph components with DuckDB • Max Halford"><meta property="og:type" content="article"><meta name=description content="Introduction Graph problems are quite common. However, it&rsquo;s rare to have access to a database offering graph semantics. There are graph databases, such as Neo4j and GraphX, but it&rsquo;s difficult to justify setting one of those up. One could simply use networkx in Python. But that only works if the graph fits in memory.
From a practical angle, the fact is that people are querying data warehouses in SQL. There are many good reasons to write graph algorithms in SQL."><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/highlight/github.css><link rel=stylesheet href=/css/index.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Permanent+Marker&display=swap" rel=stylesheet><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><article class=post id=article><div class="row center-xs" style=text-align:left><div class="col-xs-12 col-sm-10 col-md-7 col-lg-5"><div class=header><header class=header-parts><div class="signatures site-title"><a href=/>Max Halford ツ</a></div><div class=header-links><a class=header-link href=/>Blog</a>
<a class=header-link href=/links/>Links</a>
<a class=header-link href=/bio/>Bio</a></div></header></div><header class=post-header><h1 class=post-title>Graph components with DuckDB</h1><div class="row post-desc"><div class="col-xs-12 post-desc-items"><time class=post-date datetime="2023-06-03 00:00:00 UTC">2023-06-03
</time><span class=posts-line-tag>data-science</span>
<span class=posts-line-tag>sql</span></div></div></header><div class="post-content markdown-body"><h2 id=toc>Table of contents</h2><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#toy-example>Toy example</a></li><li><a href=#a-working-implementation>A working implementation</a></li><li><a href=#performance>Performance</a></li></ul></nav><h2 id=introduction>Introduction</h2><p>Graph problems are quite common. However, it&rsquo;s rare to have access to a database offering graph semantics. There are graph databases, such as <a href=https://neo4j.com/>Neo4j</a> and <a href=https://spark.apache.org/docs/latest/graphx-programming-guide.html>GraphX</a>, but it&rsquo;s difficult to justify setting one of those up. One could simply use <a href=https://networkx.org/>networkx</a> in Python. But that only works if the graph fits in memory.</p><p>From a practical angle, the fact is that people are querying data warehouses in SQL. There are many good reasons to write graph algorithms in SQL. And anyway, one may argue that graphs are a special case of the <a href=https://www.wikiwand.com/en/Relational_model>relational model</a>.</p><p>An ex-colleague recently shared a problem he was pulling his hair on:</p><blockquote><p>I have a list of companies. Each company can have several admins. An admin may administrate several companies. Companies share a link because they might have at least one admin in common, and vice versa.</p><p>Question: <em>How can I find groups of companies and admins that are connected with each other?</em></p></blockquote><p>As you might guess, this boils down to finding <a href=https://www.wikiwand.com/en/Component_(graph_theory)>components in a graph</a>.</p><p>My ex-colleague had a few tens of thousands of rows sitting in a Snowflake table. Each row linking an admin to a company. It took us an hour to obtain a working solution in SQL. But it involved a recursive query with an uninspired stopping condition based on the recursion depth. Moreover, the query took a (painful) few minutes to run.</p><p>This post is an attempt at sharing a clean and reasonably fast solution.</p><h2 id=toy-example>Toy example</h2><p>Let me illustrate with an example, which will also serve as a unit test. Let&rsquo;s say there are customers $\{1, &mldr;, 8\}$ that have visited restaurants $\{A, &mldr;, G\}$. Some customers may have visited several restaurants, some none at all.</p><div align=center><figure style=width:90%;margin:0><img style=box-shadow:none src=/img/blog/graph-components-duckdb/directed.svg><figcaption>A toy graph of 15 nodes with 5 components</figcaption></figure></div></br><p>Let&rsquo;s say we have to find groups of customers/restaurants that are connected to each other, either directly or indirectly. For instance, this may be because it&rsquo;s COVID, and we want to notify customers that were at a restaurant which was visited by an infected person. We won&rsquo;t worry about visiting times, though &ndash; people should only care if they visited the restaurant at the same time.</p><p>The above graph is <a href=https://www.wikiwand.com/en/Bipartite_graph>bipartite</a>, in that the edges always go from a customer to a restaurant &ndash; and not, say, from a customer to a customer. This is just a special case of a graph. If we have an algorithm to find components in any graph, then it would also work for bipartite graphs.</p><h2 id=a-working-implementation>A working implementation</h2><p>I&rsquo;ll use DuckDB as an example. A nice thing about DuckDB is that it plays nicely with Python. DuckDB query convert to pandas dataframes without any fuss, and vice versa. First, let&rsquo;s list the visits from customers to restaurants:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- visits
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>VALUES</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- Component #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>(</span><span class=s1>&#39;1&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;A&#39;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=s1>&#39;2&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;A&#39;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- Component #4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>(</span><span class=s1>&#39;4&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;C&#39;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=s1>&#39;4&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;D&#39;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- Component #5
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>(</span><span class=s1>&#39;5&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;E&#39;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=s1>&#39;6&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;E&#39;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=s1>&#39;6&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;F&#39;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=s1>&#39;7&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;F&#39;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=s1>&#39;7&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;G&#39;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>(</span><span class=s1>&#39;8&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;G&#39;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>visits</span><span class=p>(</span><span class=n>person</span><span class=p>,</span><span class=w> </span><span class=n>place</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>I&rsquo;ve only written down the SQL code, and omitted the Python part. But the latter simple, as you can see after clicking on the details below. I like this way of being able to break a large query into steps, as it allows inspecting intermediary results.</p><details><summary>Python code</summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>duckdb</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>visits</span> <span class=o>=</span> <span class=n>duckdb</span><span class=o>.</span><span class=n>sql</span><span class=p>(</span><span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>SELECT *
</span></span></span><span class=line><span class=cl><span class=s1>FROM (
</span></span></span><span class=line><span class=cl><span class=s1>    VALUES
</span></span></span><span class=line><span class=cl><span class=s1>    -- Component #1
</span></span></span><span class=line><span class=cl><span class=s1>    (&#39;1&#39;, &#39;A&#39;),
</span></span></span><span class=line><span class=cl><span class=s1>    (&#39;2&#39;, &#39;A&#39;),
</span></span></span><span class=line><span class=cl><span class=s1>    -- Component #4
</span></span></span><span class=line><span class=cl><span class=s1>    (&#39;4&#39;, &#39;C&#39;),
</span></span></span><span class=line><span class=cl><span class=s1>    (&#39;4&#39;, &#39;D&#39;),
</span></span></span><span class=line><span class=cl><span class=s1>    -- Component #5
</span></span></span><span class=line><span class=cl><span class=s1>    (&#39;5&#39;, &#39;E&#39;),
</span></span></span><span class=line><span class=cl><span class=s1>    (&#39;6&#39;, &#39;E&#39;),
</span></span></span><span class=line><span class=cl><span class=s1>    (&#39;6&#39;, &#39;F&#39;),
</span></span></span><span class=line><span class=cl><span class=s1>    (&#39;7&#39;, &#39;F&#39;),
</span></span></span><span class=line><span class=cl><span class=s1>    (&#39;7&#39;, &#39;G&#39;),
</span></span></span><span class=line><span class=cl><span class=s1>    (&#39;8&#39;, &#39;G&#39;)
</span></span></span><span class=line><span class=cl><span class=s1>) AS visits(person, place)
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>to_df</span><span class=p>()</span>
</span></span></code></pre></div></details><p>I&rsquo;ve omitted the 2nd and 3rd components. That&rsquo;s because they only have a single node. We&rsquo;ll have to make sure they&rsquo;re not omitted, because they are valid components. Before that, let&rsquo;s turn this bipartite graph into a more general undirected graph. We do that by duplicating the <code>visits</code> and switching the two columns.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- edges
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=n>person</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>src</span><span class=p>,</span><span class=w> </span><span class=n>place</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>dst</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>visits</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UNION</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>place</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>src</span><span class=p>,</span><span class=w> </span><span class=n>person</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>dst</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>visits</span><span class=w>
</span></span></span></code></pre></div><pre tabindex=0><code>┌─────────┬─────────┐
│   src   │   dst   │
│ varchar │ varchar │
├─────────┼─────────┤
│ A       │ 1       │
│ A       │ 2       │
│ C       │ 4       │
│ D       │ 4       │
│ E       │ 5       │
│ E       │ 6       │
│ F       │ 6       │
│ F       │ 7       │
│ G       │ 7       │
│ G       │ 8       │
│ 1       │ A       │
│ 2       │ A       │
│ 4       │ C       │
│ 4       │ D       │
│ 5       │ E       │
│ 6       │ E       │
│ 6       │ F       │
│ 7       │ F       │
│ 7       │ G       │
│ 8       │ G       │
├─────────┴─────────┤
│      20 rows      │
└───────────────────┘
</code></pre><p>This yields a table with double the amount of rows. We can derive the list of nodes from this <code>edges</code> table:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- nodes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=n>src</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>node</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>edges</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UNION</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;3&#39;</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;B&#39;</span><span class=p>)</span><span class=w> </span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><pre tabindex=0><code>┌─────────┐
│  node   │
│ varchar │
├─────────┤
│ 3       │
│ B       │
│ A       │
│ C       │
│ D       │
│ E       │
│ F       │
│ G       │
│ 1       │
│ 2       │
│ 4       │
│ 5       │
│ 6       │
│ 7       │
│ 8       │
├─────────┤
│ 15 rows │
└─────────┘
</code></pre><p>That was a bit of data munging to get the list of nodes and edges. But you might already have that in some different shape. What follows is the crux of this article. Indeed, we have everything needed to implement a connected components algorithm. This is <a href=https://www.wikiwand.com/en/Connected_component_(graph_theory)#Algorithms>usually done</a> with a search algorithm, be it <a href=https://www.wikiwand.com/en/Breadth-first_search>BFS</a> or <a href=https://www.wikiwand.com/en/Depth-first_search>DFS</a>. A variation is necessary to function with relational semantics.</p><p>I have to admit, I got an implementation from Torsten Grust&rsquo;s <a href="https://www.youtube.com/watch?v=L967JqNFxkw">tutorial</a>. He calls it <em>parallel walks</em>, and it&rsquo;s admittedly rather elegant. The following code is more or less copy/pasted from that tutorial.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>WITH</span><span class=w> </span><span class=k>RECURSIVE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>walks</span><span class=p>(</span><span class=n>node</span><span class=p>,</span><span class=w> </span><span class=n>front</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>SELECT</span><span class=w> </span><span class=n>node</span><span class=p>,</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>front</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>FROM</span><span class=w> </span><span class=n>nodes</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>UNION</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>SELECT</span><span class=w> </span><span class=n>walks</span><span class=p>.</span><span class=n>node</span><span class=p>,</span><span class=w> </span><span class=n>edges</span><span class=p>.</span><span class=n>dst</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>front</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>FROM</span><span class=w> </span><span class=n>walks</span><span class=p>,</span><span class=w> </span><span class=n>edges</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>WHERE</span><span class=w> </span><span class=n>walks</span><span class=p>.</span><span class=n>front</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>edges</span><span class=p>.</span><span class=n>src</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>components</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>SELECT</span><span class=w> </span><span class=n>node</span><span class=p>,</span><span class=w> </span><span class=k>MIN</span><span class=p>(</span><span class=n>front</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>FROM</span><span class=w> </span><span class=n>walks</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>node</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>components</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>component</span><span class=p>,</span><span class=w> </span><span class=n>node</span><span class=w>
</span></span></span></code></pre></div><pre tabindex=0><code>┌─────────┬───────────┐
│  node   │ component │
│ varchar │  varchar  │
├─────────┼───────────┤
│ 1       │ 1         │
│ 2       │ 1         │
│ A       │ 1         │
│ 3       │ 3         │
│ 4       │ 4         │
│ C       │ 4         │
│ D       │ 4         │
│ 5       │ 5         │
│ 6       │ 5         │
│ 7       │ 5         │
│ 8       │ 5         │
│ E       │ 5         │
│ F       │ 5         │
│ G       │ 5         │
│ B       │ B         │
├─────────┴───────────┤
│ 15 rows   2 columns │
└─────────────────────┘
</code></pre><p>The assignments are correct. There&rsquo;s 15 nodes grouped into 5 components. The component names are not labeled from 1 to 5, but that&rsquo;s because I used <code>MIN(node)</code> to label each component. There are other ways to proceed.</p><p>The algorithm is quite straightforward:</p><ol><li>Start by listing each node, and build a &ldquo;front&rdquo; for each node, which at first only contains said node.</li><li>Join each front with the edge sources, and append the edges destinations with the front.</li><li>Repeat step 2 with the new front, using recursion.</li></ol><p>The stopping condition isn&rsquo;t obvious, though. The query works because of the <code>UNION</code> operator. Initially, the nodes are listed by themselves, and each node&rsquo;s front is composed of only said node. Then, the front is joined with the edge sources, and the front is extended by including the edge destinations. However, these new pairs are only added to the new front if they aren&rsquo;t already in the existing front. This is how the recursion stops. Torsten Grust provides a good visualization, working out the recursion on a toy example:</p><p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src="https://www.youtube.com/embed/L967JqNFxkw?start=1281" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div></br></p><p>Having a working implementation is already a success. It&rsquo;s cleaner than the hacky solution we came up with my colleague.</p><p>Now how about performance?</p><h2 id=performance>Performance</h2><p>The only issue with the above implementation is its inefficiency. Before the <code>MIN(front) ... GROUP BY</code> reduction, the <code>walks</code> CTE contains 69 rows. What&rsquo;s happening is that the <code>walks</code> table lists all the pairs of nodes that are linked to each other in some way. Indeed, the 69 figure decomposes as</p><p>$$69 = 3^2 + 1^2 + 1^2 + 3^2 + 7^2$$</p><p>This is clearly problematic. In a real dataset, it&rsquo;s not unreasonable to expect components with some tens of thousands of nodes. $10,000^2 = 100,000,000$ is a large number and will rapidly saturate a computer&rsquo;s main memory. In the worst case, where there is a single component containing all <code>n</code> nodes, there would be $n^2$ components.</p><p>In fact, I&rsquo;ve tried running the above logic on the <a href=https://developer.imdb.com/non-commercial-datasets/#titleprincipalstsvgz>title.principals.tsv.gz</a> file shared by IMDb. This dataset contains 56,328,578 rows, representing actors who played in movies. The query didn&rsquo;t take long to crash.</p><pre tabindex=0><code>duckdb.OutOfMemoryException
Out of Memory Error
could not allocate block of 262144 bytes
(13743722496/13743895347 used)
</code></pre><p>As a reminder, our goal boils down to determining which nodes are part of the same set. The fundamental issue is that we&rsquo;re representing these sets in the most inefficient way possible. The memory footprint of a set should be linear, because there&rsquo;s only a need to mention each node once. But here we&rsquo;re explicitly listing each pair within each component, which results in quadratic memory usage.</p><p>That said, the idea of extending a front of nodes is the right one. It&rsquo;s simply that we&rsquo;re not using the right data structure to materialize said front. Ideally, each front would be represented with an actual set, on which set semantics could be applied. The fronts would then be <a href=https://www.wikiwand.com/en/Disjoint_sets>disjoint sets</a>. If two nodes are adjacent to one another, then their fronts would be merged. This is reminiscent of <a href="https://www.wikiwand.com/en/Kruskal's_algorithm">Kruskal&rsquo;s algorithm</a>.</p><p>The only issue is that I have no idea how to do this with DuckDB! The latter has a <a href=https://duckdb.org/docs/sql/data_types/list><code>List</code> data type</a>, but not an equivalent for sets. I leave it to the reader to take up the baton 🦆</p></div><script type=text/javascript>var s=document.createElement("script");s.setAttribute("src","https://utteranc.es/client.js"),s.setAttribute("repo","MaxHalford/maxhalford.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",null),s.setAttribute("theme","github-light"),document.body.appendChild(s)</script><div style=display:flex;flex-direction:row;justify-content:center;align-items:center;gap:20px;margin-bottom:30px><div class=do-the-thing><div class=elevator><svg class="sweet-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" enable-background="new 0 0 100 100" height="100" width="100"><path d="M70 47.5H30c-1.4.0-2.5 1.1-2.5 2.5v40c0 1.4 1.1 2.5 2.5 2.5h40c1.4.0 2.5-1.1 2.5-2.5V50C72.5 48.6 71.4 47.5 70 47.5zm-22.5 40h-5v-25h5v25zm10 0h-5v-25h5v25zm10 0h-5V60c0-1.4-1.1-2.5-2.5-2.5H40c-1.4.0-2.5 1.1-2.5 2.5v27.5h-5v-35h35v35z"/><path d="M50 42.5c1.4.0 2.5-1.1 2.5-2.5V16l5.7 5.7c.5.5 1.1.7 1.8.7s1.3-.2 1.8-.7c1-1 1-2.6.0-3.5l-10-10c-1-1-2.6-1-3.5.0l-10 10c-1 1-1 2.6.0 3.5 1 1 2.6 1 3.5.0l5.7-5.7v24c0 1.4 1.1 2.5 2.5 2.5z"/></svg>Back to the top</div></div><iframe src=https://github.com/sponsors/MaxHalford/button title="Sponsor MaxHalford" height=32 width=114 style=border:0;border-radius:6px></iframe></div><script src=https://cdnjs.cloudflare.com/ajax/libs/elevator.js/1.0.1/elevator.min.js></script><script>var elementButton=document.querySelector(".elevator"),elevator=new Elevator({element:elementButton,mainAudio:"/music/elevator.mp3",endAudio:"/music/ding.mp3"})</script><style>.down-arrow{font-size:120px;margin-top:90px;margin-bottom:90px;text-shadow:0 -20px #0c1f31,0 0 #c33329;color:transparent;-webkit-transform:scaleY(.8);-moz-transform:scaleY(.8);transform:scaleY(.8)}.elevator{text-align:center;cursor:pointer;width:140px;margin:auto}.elevator:hover{opacity:.7}.elevator svg{width:40px;height:40px;display:block;margin:auto;margin-bottom:5px}</style><div class=related-content><h3 style=margin-top:10px!important;margin-bottom:10px!important>Related posts</h3><ul style=margin-top:0><li><a href=/blog/grouping-sets/>Dashboards and GROUPING SETS</a></li><li><a href=/blog/sql-cross-correlations/>Computing cross-correlations in SQL</a></li><li><a href=/slides/docker-data-science.pdf>Docker for data science @ HelloFresh Berlin</a></li></ul></div></div></div></article></body></html>