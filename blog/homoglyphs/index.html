<!doctype html><html lang=en><head><script defer src=https://unpkg.com/@tinybirdco/flock.js data-host=https://api.tinybird.co data-token=p.eyJ1IjogImMwMjJhMjg1LWJmY2YtNDc0OC1hYzczLTJhMDQ1Njk3NTI0YyIsICJpZCI6ICIzNjc3NjQ3Ny04MTE2LTRmYWQtYjcwMy1iZmM3YjMwZGJjMjMifQ.A0vHm-VWbXG6uBFZiwuspN_AyfSYNrdZE3IgwgWSt4g></script><meta charset=utf-8><meta name=generator content="Hugo 0.119.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Max Halford"><meta property="og:url" content="https://maxhalford.github.io/blog/homoglyphs/"><link rel=canonical href=https://maxhalford.github.io/blog/homoglyphs/><meta property="og:title" content="Homoglyphs: different characters that look identical"><meta property="og:description" content="A wild homoglyph appears For instance, can you tell if there&rsquo;s a difference between H and Œó? How about N and Œù? These characters may seem identical, but they are actually different. You can try this out for yourself in Python:
>>> 'H' == 'Œó' False >>> 'N' == 'Œù' False Indeed, these all represent different Unicode characters:
>>> ord('H'), ord('Œó') (72, 919) >>> ord('N'), ord('Œù') (78, 925) Œó in fact represents the capital Eta letter, while Œù is a capital Nu."><meta property="og:type" content="article"><meta property="og:url" content="https://maxhalford.github.io/blog/homoglyphs/"><meta property="og:image" content="https://maxhalford.github.io/img/beach.jpg"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-08-19T00:00:00+00:00"><meta property="article:modified_time" content="2021-08-19T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://maxhalford.github.io/img/beach.jpg"><meta name=twitter:title content="Homoglyphs: different characters that look identical"><meta name=twitter:description content="A wild homoglyph appears For instance, can you tell if there&rsquo;s a difference between H and Œó? How about N and Œù? These characters may seem identical, but they are actually different. You can try this out for yourself in Python:
>>> 'H' == 'Œó' False >>> 'N' == 'Œù' False Indeed, these all represent different Unicode characters:
>>> ord('H'), ord('Œó') (72, 919) >>> ord('N'), ord('Œù') (78, 925) Œó in fact represents the capital Eta letter, while Œù is a capital Nu."><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ü¶î</text></svg>"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/maxhalford.github.io\/"},"articleSection":"blog","name":"Homoglyphs: different characters that look identical","headline":"Homoglyphs: different characters that look identical","description":"A wild homoglyph appears For instance, can you tell if there\u0026rsquo;s a difference between H and Œó? How about N and Œù? These characters may seem identical, but they are actually different. You can try this out for yourself in Python:\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;H\u0026#39; == \u0026#39;Œó\u0026#39; False \u0026gt;\u0026gt;\u0026gt; \u0026#39;N\u0026#39; == \u0026#39;Œù\u0026#39; False Indeed, these all represent different Unicode characters:\n\u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;H\u0026#39;), ord(\u0026#39;Œó\u0026#39;) (72, 919) \u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;N\u0026#39;), ord(\u0026#39;Œù\u0026#39;) (78, 925) Œó in fact represents the capital Eta letter, while Œù is a capital Nu.","inLanguage":"en-US","author":"Max Halford","creator":"Max Halford","publisher":"Max Halford","accountablePerson":"Max Halford","copyrightHolder":"Max Halford","copyrightYear":"2021","datePublished":"2021-08-19 00:00:00 \u002b0000 UTC","dateModified":"2021-08-19 00:00:00 \u002b0000 UTC","url":"https:\/\/maxhalford.github.io\/blog\/homoglyphs\/","keywords":["text-processing"]}</script><title>Homoglyphs: different characters that look identical ‚Ä¢ Max Halford</title><meta property="og:title" content="Homoglyphs: different characters that look identical ‚Ä¢ Max Halford"><meta property="og:type" content="article"><meta name=description content="A wild homoglyph appears For instance, can you tell if there&rsquo;s a difference between H and Œó? How about N and Œù? These characters may seem identical, but they are actually different. You can try this out for yourself in Python:
>>> 'H' == 'Œó' False >>> 'N' == 'Œù' False Indeed, these all represent different Unicode characters:
>>> ord('H'), ord('Œó') (72, 919) >>> ord('N'), ord('Œù') (78, 925) Œó in fact represents the capital Eta letter, while Œù is a capital Nu."><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/highlight/github.css><link rel=stylesheet href=/css/index.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Permanent+Marker&display=swap" rel=stylesheet><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><article class=post id=article><div class="row center-xs" style=text-align:left><div class="col-xs-12 col-sm-10 col-md-7 col-lg-5"><div class=header><header class=header-parts><div class="signatures site-title"><a href=/>Max Halford ü¶î</a></div><div class=header-links><a class=header-link href=/>Blog</a>
<a class=header-link href=/links/>Links</a>
<a class=header-link href=/bio/>Bio</a></div></header></div><header class=post-header><h1 class=post-title>Homoglyphs: different characters that look identical</h1><div class="row post-desc"><div class="col-xs-12 post-desc-items"><time class=post-date datetime="2021-08-19 00:00:00 UTC">2021-08-19</time>
<span class=posts-line-tag>text-processing</span></div></div></header><div class="post-content markdown-body"><h2 id=toc>Table of contents</h2><nav id=TableOfContents><ul><li><a href=#a-wild-homoglyph-appears>A wild homoglyph appears</a></li><li><a href=#some-typography-terminology>Some typography terminology</a></li><li><a href=#bitmap-font-comparison>Bitmap font comparison</a></li><li><a href=#searching-for-homoglyphs>Searching for homoglyphs</a></li><li><a href=#seeing-further-confusable-characters>Seeing further: confusable characters</a></li></ul></nav><h2 id=a-wild-homoglyph-appears>A wild homoglyph appears</h2><p>For instance, can you tell if there&rsquo;s a difference between <code>H</code> and <code>Œó</code>? How about <code>N</code> and <code>Œù</code>? These characters may seem identical, but they are actually different. You can try this out for yourself in Python:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=s1>&#39;H&#39;</span> <span class=o>==</span> <span class=s1>&#39;Œó&#39;</span>
</span></span><span class=line><span class=cl><span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=s1>&#39;N&#39;</span> <span class=o>==</span> <span class=s1>&#39;Œù&#39;</span>
</span></span><span class=line><span class=cl><span class=kc>False</span>
</span></span></code></pre></div><p>Indeed, these all represent different Unicode characters:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>ord</span><span class=p>(</span><span class=s1>&#39;H&#39;</span><span class=p>),</span> <span class=nb>ord</span><span class=p>(</span><span class=s1>&#39;Œó&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=mi>72</span><span class=p>,</span> <span class=mi>919</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>ord</span><span class=p>(</span><span class=s1>&#39;N&#39;</span><span class=p>),</span> <span class=nb>ord</span><span class=p>(</span><span class=s1>&#39;Œù&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=mi>78</span><span class=p>,</span> <span class=mi>925</span><span class=p>)</span>
</span></span></code></pre></div><p><code>Œó</code> in fact represents the capital <a href=https://www.wikiwand.com/en/Eta>Eta</a> letter, while <code>Œù</code> is a capital <a href=https://www.wikiwand.com/en/Nu_(letter)>Nu</a>. In fact, entering <code>H</code> or <code>Œó</code> in Google will produce different results. The same goes for <code>N</code> and <code>Œù</code>.</p><p>These pairs of seemingly identical characters are called <a href=https://www.wikiwand.com/en/Homoglyph>homoglyphs</a>. I encountered them when working with <a href=https://github.com/pdfminer/pdfminer.six>PDFMiner</a>. I didn&rsquo;t understand at first why one of my regex patterns was not matching a given piece of text. Before losing my sanity, I compared each character in the regex to each character in the text one by one. I then realized that two visually identical characters didn&rsquo;t necessarily represent the same thing.</p><p>I believe homoglyphs are quite a niche topic. In my experience, OCR tools like <a href=https://aws.amazon.com/fr/textract/>Amazon Textract</a> behave well and produce sane outputs. And yet, it&rsquo;s important to know homoglyphs exist if you&rsquo;re looking to correct OCR outputs. The main purpose of this blog post is simply to spread the word on homoglyphs. As a data scientist, I had never heard of them before getting bitten by them in my day job. I had to Google &ldquo;letters that look the same but are not the same&rdquo; to learn that this was a thing. Homoglyphs are probably common knowledge if you have a decent background in software engineering. But not everyone is that lucky!</p><p>I thought it would be interesting to write a script that searches for all possible homoglyphs for a given typeface. But before we get into that, let me try to summarise some typography terminology.</p><h2 id=some-typography-terminology>Some typography terminology</h2><ul><li><strong>Typeface</strong> ‚Äî that&rsquo;s what most people usually mean when they say font. It&rsquo;s the name of a style, such as Helvetica, Times New Roman, or Comic Sans. I&rsquo;ve also seen these being called &ldquo;font families&rdquo;.</li></ul><div align=center style="margin:0 10%"><figure><img src=/img/blog/character-similarity-ocr-correction/miller-specimen.png><figcaption>The Miller typeface ‚Äî specimens such as above are commonly used to display typefaces.</figcaption></figure></div><ul><li><strong>Font</strong> ‚Äî it&rsquo;s the materialization of a typeface. A font is essentially a (typeface, weight, size) triplet. For instance, one could say &ldquo;I&rsquo;m using Helvetica (font) bold (weight) 12pt (size) as my font&rdquo;.</li></ul><div align=center style="padding:0 5%"><figure><img style=padding:5% src=/img/blog/character-similarity-ocr-correction/miller-fonts.png><figcaption>Each variation of the Miller typeface is a distinct font.</figcaption></figure></div><ul><li><p><strong>Character</strong> ‚Äî it&rsquo;s the smallest building block of a piece of numeric text. <code>$</code>, <code>!</code>, <code>a</code>, <code>A</code>, <code>√†</code> <code>1</code> are all characters. <strong>Letters</strong> are specific characters that belong to an alphabet.</p></li><li><p><strong>Glyph</strong> ‚Äî I&rsquo;m going to quote <a href=https://docs.python.org/3/howto/unicode.html>Python&rsquo;s Unicode documentation</a> here:</p><blockquote><p>A character is represented on a screen or on paper by a set of graphical elements that‚Äôs called a glyph. The glyph for an uppercase A, for example, is two diagonal strokes and a horizontal stroke, though the exact details will depend on the font being used.</p></blockquote></li></ul><p>Broadly speaking, a character is materialized in a font by a glyph. To be precise, I would say that each character is represented with a glyph for a given typeface, not a font. I would be surprised if fonts from the same typeface represented the same character with different glyphs. Anyway, I&rsquo;m nitpicking.</p><p>Importantly, the same glyph can be used to represent different characters. For instance, the same glyph is used to represent the characters &ldquo;H&rdquo; and &ldquo;Œó&rdquo;. But that&rsquo;s true because of the typeface I&rsquo;m using in my text editor, which is Microsoft&rsquo;s <a href=https://github.com/microsoft/cascadia-code>Cascadia Code</a>.</p><h2 id=bitmap-font-comparison>Bitmap font comparison</h2><p>I would like some way to tell if two characters are represented with the same glyph in a given font. There are essentially two different kinds of <a href=https://www.wikiwand.com/en/Computer_font>computer fonts</a>. There are vectorized fonts, where the glyphs are described geometrically using <a href=https://www.wikiwand.com/en/B%C3%A9zier_curve>B√©zier curves</a> or stroke information. The great advantage is that they can scale to any size. However, I don&rsquo;t see a straightforward way to compare glyphs that are described mathematically. There are also <a href=https://www.wikiwand.com/en/Computer_font#/Bitmap_fonts>bitmap fonts</a>, which represent each glyph as a matrix of pixels, usually stored as a <a href=https://www.wikiwand.com/en/Bitmap>bitmap</a> &ndash; hence the name. The pixels might be <a href=https://www.wikiwand.com/en/Binary_image>binary</a> or take on <a href=https://www.wikiwand.com/en/Grayscale>grayscale</a> values.</p><p>Manipulating the pixel representations of glyphs is quite straightforward. For instance, check out <a href=https://observablehq.com/@bmschmidt/umap-clustering-of-unicode-characters-from-pixel-values>this</a> amazing <a href=https://github.com/PAIR-code/umap-js>UMAP clustering</a> of Unicode characters from their pixel values. Nowadays, most fonts are expressed in vectorised formats, such as <a href=https://www.wikiwand.com/en/TrueType>TrueType</a> &ndash; i.e. <code>.ttf</code> files. But a vectorized font can be converted to a bitmap font through a process called <a href=https://www.wikiwand.com/en/Font_rasterization>rasterisation</a>.</p><p>I decided to use <a href=https://pillow.readthedocs.io/en/stable/>Pillow</a> to do the rasterisation. Here is a function that does the job:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>PIL</span> <span class=kn>import</span> <span class=n>Image</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>PIL</span> <span class=kn>import</span> <span class=n>ImageFont</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>PIL</span> <span class=kn>import</span> <span class=n>ImageDraw</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>draw_char</span><span class=p>(</span><span class=n>char</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>typeface</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>size</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Image</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>font</span> <span class=o>=</span> <span class=n>ImageFont</span><span class=o>.</span><span class=n>truetype</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=n>typeface</span><span class=si>}</span><span class=s1>.ttf&#39;</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>img</span> <span class=o>=</span> <span class=n>Image</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=s1>&#39;L&#39;</span><span class=p>,</span> <span class=p>(</span><span class=n>size</span><span class=p>,</span> <span class=n>size</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>draw</span> <span class=o>=</span> <span class=n>ImageDraw</span><span class=o>.</span><span class=n>Draw</span><span class=p>(</span><span class=n>img</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>draw</span><span class=o>.</span><span class=n>text</span><span class=p>((</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span> <span class=n>char</span><span class=p>,</span> <span class=mi>255</span><span class=p>,</span> <span class=n>font</span><span class=o>=</span><span class=n>font</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>img</span>
</span></span></code></pre></div><p>The function returns a <code>PIL.Image</code>. This is a <a href=https://www.wikiwand.com/en/Grayscale>grayscale</a> image. To determine if two characters are identical, we can render both characters and compare them. We first need to convert them to <code>numpy.ndarray</code>s to make them comparable. Let&rsquo;s write a little function for this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>render</span><span class=p>(</span><span class=n>char</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>typeface</span><span class=o>=</span><span class=s1>&#39;Helvetica&#39;</span><span class=p>,</span> <span class=n>size</span><span class=o>=</span><span class=mi>10</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>img</span> <span class=o>=</span> <span class=n>draw_char</span><span class=p>(</span><span class=n>char</span><span class=p>,</span> <span class=n>typeface</span><span class=o>=</span><span class=n>typeface</span><span class=p>,</span> <span class=n>size</span><span class=o>=</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>img</span><span class=p>)</span>
</span></span></code></pre></div><p>Now let&rsquo;s compare <code>H</code> with <code>Œó</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=p>(</span><span class=n>render</span><span class=p>(</span><span class=s1>&#39;H&#39;</span><span class=p>)</span> <span class=o>==</span> <span class=n>render</span><span class=p>(</span><span class=s1>&#39;Œó&#39;</span><span class=p>))</span><span class=o>.</span><span class=n>all</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=kc>False</span>
</span></span></code></pre></div><p>Oups, I would have expected both arrays to be equal. Let&rsquo;s take a look at them:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>render</span><span class=p>(</span><span class=s1>&#39;H&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>([[</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>196</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>124</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>196</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>124</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>196</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>124</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>246</span><span class=p>,</span> <span class=mi>216</span><span class=p>,</span> <span class=mi>216</span><span class=p>,</span> <span class=mi>216</span><span class=p>,</span> <span class=mi>236</span><span class=p>,</span> <span class=mi>124</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>196</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>124</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>196</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>124</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>196</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>124</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>196</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>124</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span>  <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span>  <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>]],</span> <span class=n>dtype</span><span class=o>=</span><span class=n>uint8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>render</span><span class=p>(</span><span class=s1>&#39;Œó&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>([[</span> <span class=mi>36</span><span class=p>,</span> <span class=mi>212</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>152</span><span class=p>,</span>  <span class=mi>92</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>36</span><span class=p>,</span> <span class=mi>212</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>152</span><span class=p>,</span>  <span class=mi>92</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>36</span><span class=p>,</span> <span class=mi>212</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>152</span><span class=p>,</span>  <span class=mi>92</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>36</span><span class=p>,</span> <span class=mi>249</span><span class=p>,</span> <span class=mi>216</span><span class=p>,</span> <span class=mi>216</span><span class=p>,</span> <span class=mi>216</span><span class=p>,</span> <span class=mi>239</span><span class=p>,</span>  <span class=mi>92</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>36</span><span class=p>,</span> <span class=mi>212</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>152</span><span class=p>,</span>  <span class=mi>92</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>36</span><span class=p>,</span> <span class=mi>212</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>152</span><span class=p>,</span>  <span class=mi>92</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>36</span><span class=p>,</span> <span class=mi>212</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>152</span><span class=p>,</span>  <span class=mi>92</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span> <span class=mi>36</span><span class=p>,</span> <span class=mi>212</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>152</span><span class=p>,</span>  <span class=mi>92</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span>  <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span>  <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span>   <span class=mi>0</span><span class=p>]],</span> <span class=n>dtype</span><span class=o>=</span><span class=n>uint8</span><span class=p>)</span>
</span></span></code></pre></div><p>The starting point of each drawing is at the top-left. We could put some effort in and make it so that the drawings are centered. But that shouldn&rsquo;t impact the comparison, so there&rsquo;s no point doing it. We can see that the same pixels are &ldquo;activated&rdquo; in each rendering. However, the grayscale values are different. We can coarse the images by converting them to bitmaps of 0s and 1s. To each the comparison across many characters, I think it also makes sense to concatenate the bitmap into a string.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=k>def</span> <span class=nf>encode_char</span><span class=p>(</span><span class=n>char</span><span class=p>,</span> <span class=n>typeface</span><span class=o>=</span><span class=s1>&#39;Helvetica&#39;</span><span class=p>,</span> <span class=n>size</span><span class=o>=</span><span class=mi>10</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>img</span> <span class=o>=</span> <span class=n>draw_char</span><span class=p>(</span><span class=n>char</span><span class=p>,</span> <span class=n>typeface</span><span class=o>=</span><span class=n>typeface</span><span class=p>,</span> <span class=n>size</span><span class=o>=</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>grayscale</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>img</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>bitmap</span> <span class=o>=</span> <span class=p>(</span><span class=n>grayscale</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=s1>&#39;uint8&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s1>&#39;&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>str</span><span class=p>,</span> <span class=p>(</span><span class=n>bit</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>bitmap</span> <span class=k>for</span> <span class=n>bit</span> <span class=ow>in</span> <span class=n>row</span><span class=p>)))</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>encode_char</span><span class=p>(</span><span class=s1>&#39;H&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;1100011000110001100011000110001111111000110001100011000110001100011000110001100000000000000000000000&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>encode_char</span><span class=p>(</span><span class=s1>&#39;Œó&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;1100011000110001100011000110001111111000110001100011000110001100011000110001100000000000000000000000&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=s1>&#39;H&#39;</span> <span class=o>==</span> <span class=s1>&#39;Œó&#39;</span>
</span></span><span class=line><span class=cl><span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>encode_char</span><span class=p>(</span><span class=s1>&#39;H&#39;</span><span class=p>)</span> <span class=o>==</span> <span class=n>encode_char</span><span class=p>(</span><span class=s1>&#39;Œó&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kc>True</span>
</span></span></code></pre></div><h2 id=searching-for-homoglyphs>Searching for homoglyphs</h2><p>We now have an <code>encode_char</code> function that allows us to tell if two characters are represented with the same glyph for a given font. Now we just have to compare all characters with each other and compare their encodings. Ok, but what do we mean by &ldquo;all characters&rdquo;? Depending on your use case, you might already have a list of characters for which you want to find homoglyphs. Meanwhile, you might not be aware of what homoglyphs you&rsquo;re prone to encounter, so considering a wide range of characters seems appropriate.</p><p>Let&rsquo;s talk a bit about <a href=https://www.wikiwand.com/en/Unicode>Unicode</a>. The short story is that it&rsquo;s a standard that lists and organises many characters. The latest stable version of Unicode, which is version 13, defines 143,859 characters. There are different ways to segment these characters into groups. For instance, there are <a href=https://www.wikiwand.com/en/Unicode_block>Unicode blocks</a>, such as <a href=https://www.wikiwand.com/en/Basic_Latin_(Unicode_block)>Basic Latin</a> and <a href=https://www.wikiwand.com/en/Latin-1_Supplement_(Unicode_block)>Latin-1 Supplement</a>. There are also <a href=https://www.wikiwand.com/en/Script_(Unicode)>scripts</a>, which regroup characters that belong to a same <a href=https://www.wikiwand.com/en/Writing_system>writing system</a>. For example, the documents I&rsquo;m looking at come from western countries that use the <a href=https://www.wikiwand.com/en/Latin_script>Latin writing system</a>, to which corresponds the <a href=https://www.wikiwand.com/en/Latin_script_in_Unicode>Latin Unicode script</a>. I find that the Unicode nomenclature is a tad complex. But then again, it&rsquo;s powerful because it organises all the different languages and symbols that exist.</p><p>Python has a <code>chr</code> function which returns the ith Unicode character:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=err>?</span><span class=nb>chr</span>
</span></span><span class=line><span class=cl><span class=n>Signature</span><span class=p>:</span> <span class=nb>chr</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=o>/</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>Docstring</span><span class=p>:</span> <span class=n>Return</span> <span class=n>a</span> <span class=n>Unicode</span> <span class=n>string</span> <span class=n>of</span> <span class=n>one</span> <span class=n>character</span> <span class=k>with</span> <span class=n>ordinal</span> <span class=n>i</span><span class=p>;</span> <span class=mi>0</span> <span class=o>&lt;=</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mh>0x10ffff</span><span class=o>.</span>
</span></span><span class=line><span class=cl><span class=n>Type</span><span class=p>:</span>      <span class=n>builtin_function_or_method</span>
</span></span></code></pre></div><p>I encoded all the characters and stored them in a <code>pandas.DataFrame</code>. I decided to render each character on a 20 by 20 grid purely heuristically.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pandas</span> <span class=k>as</span> <span class=nn>pd</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>tqdm</span> <span class=kn>import</span> <span class=n>tqdm</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Meta: I like walrus operators ü§ü</span>
</span></span><span class=line><span class=cl><span class=n>char_codes</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;char&#39;</span><span class=p>:</span> <span class=p>(</span><span class=n>char</span> <span class=o>:=</span> <span class=nb>chr</span><span class=p>(</span><span class=n>i</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;code&#39;</span><span class=p>:</span> <span class=p>(</span><span class=n>code</span> <span class=o>:=</span> <span class=n>encode_char</span><span class=p>(</span><span class=n>char</span><span class=p>,</span> <span class=n>size</span><span class=o>=</span><span class=mi>20</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;n_bits&#39;</span><span class=p>:</span> <span class=nb>sum</span><span class=p>(</span><span class=n>bit</span> <span class=o>==</span> <span class=s1>&#39;1&#39;</span> <span class=k>for</span> <span class=n>bit</span> <span class=ow>in</span> <span class=n>code</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>tqdm</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mh>0x10ffff</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 1114111/1114111 [09:37&lt;00:00, 1929.22it/s]
</code></pre><p>That&rsquo;s a lot of characters. It&rsquo;s more than the 143,859 characters in the latest Unicode standard. The <a href=https://unicode.org/faq/basic_q.html>Unicode FAQ</a> gives some pointers as to why this is the case. The answer is a bit complicated.</p><p>Anyway, now that each character has been encoded, I can group the characters with the same encodings together. I&rsquo;m going to ignore the characters that render all black.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>groups</span> <span class=o>=</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>char_codes</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=n>query</span><span class=p>(</span><span class=s1>&#39;n_bits &gt; 0&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=n>groupby</span><span class=p>(</span><span class=s1>&#39;code&#39;</span><span class=p>)[</span><span class=s1>&#39;char&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=n>apply</span><span class=p>(</span><span class=nb>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>After the <code>groupby</code>, I need to filter out the groups that contain a single element, because those are the characters without any homoglyphs. I&rsquo;m also removing very large homoglyph groups because they&rsquo;re probably bogus.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>homoglyph_groups</span> <span class=o>=</span> <span class=n>groups</span><span class=p>[</span><span class=mi>1</span> <span class=o>&lt;</span> <span class=n>groups</span><span class=o>.</span><span class=n>apply</span><span class=p>(</span><span class=nb>len</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>10_000</span><span class=p>]</span>
</span></span></code></pre></div><p>Let&rsquo;s see how many groups of homoglyphs there are.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>homoglyph_groups</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=mi>136</span>
</span></span></code></pre></div><p>We can take a look at some groups at random:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=k>for</span> <span class=n>group</span> <span class=ow>in</span> <span class=n>homoglyph_groups</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=mi>10</span><span class=p>):</span>
</span></span><span class=line><span class=cl><span class=o>...</span>     <span class=nb>print</span><span class=p>(</span><span class=s1>&#39; &#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>group</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>·ΩÆ</span> <span class=n>·æÆ</span>
</span></span><span class=line><span class=cl><span class=n>…Å</span> <span class=n> î</span>
</span></span><span class=line><span class=cl><span class=n>≈É</span> <span class=n>«∏</span>
</span></span><span class=line><span class=cl><span class=n>·∏∂</span> <span class=n>·∏∏</span>
</span></span><span class=line><span class=cl><span class=n>W</span> <span class=n>≈¥</span> <span class=n>·∫Ä</span> <span class=n>·∫Ç</span> <span class=n>·∫Ñ</span> <span class=n>·∫Ü</span>
</span></span><span class=line><span class=cl><span class=n>œé</span> <span class=n>œé</span>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=n>·∫ó</span>
</span></span><span class=line><span class=cl><span class=err>‚Ö•</span> <span class=err>‚Ö¶</span> <span class=err>‚Öß</span>
</span></span><span class=line><span class=cl><span class=n>∆†</span> <span class=n>·ªö</span> <span class=n>·ªú</span> <span class=n>·ª†</span>
</span></span><span class=line><span class=cl><span class=n>·∏∑</span> <span class=n>·∏π</span> <span class=n>·ªä</span>
</span></span></code></pre></div><p>So what if we want to determine the homoglyphs for a given character? We can do that by creating a <code>dict</code> that maps each character to its homoglyphs.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>defaultdict</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>permutations</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>homoglyphs</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>set</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>group</span> <span class=ow>in</span> <span class=n>homoglyph_groups</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=ow>in</span> <span class=n>permutations</span><span class=p>(</span><span class=n>group</span><span class=p>,</span> <span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>homoglyphs</span><span class=p>[</span><span class=n>a</span><span class=p>]</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>b</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>homoglyphs</span><span class=p>(</span><span class=s1>&#39;D&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>‚ÖÆ</span> <span class=n>·∏ä</span> <span class=n>ƒé</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>homoglyphs</span><span class=p>(</span><span class=s1>&#39;H&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>·∏¢</span> <span class=n>–ù</span> <span class=n>·∏¶</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>homoglyphs</span><span class=p>(</span><span class=s1>&#39;N&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>√ë</span> <span class=n>·πÑ</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>homoglyphs</span><span class=p>(</span><span class=s1>&#39;O&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>√î</span> <span class=n>√ì</span> <span class=n>«ë</span> <span class=n>√í</span> <span class=n>·πå</span> <span class=n>·πê</span> <span class=n>≈ê</span> <span class=n>»™</span> <span class=n>»å</span> <span class=n>»Æ</span> <span class=n>≈é</span> <span class=n>√ñ</span> <span class=n>»∞</span> <span class=n>·ªê</span> <span class=n>·ªí</span> <span class=n>√ï</span> <span class=n>≈å</span> <span class=n>·πí</span> <span class=n>·ªî</span>
</span></span></code></pre></div><p>What&rsquo;s interesting is that these characters actually look different, at least on my laptop. That&rsquo;s probably because some details have been smoothed out during the rasterisation phase due to the grid being too small. Increasing the grid size would remove some of these false positives, at the cost of a higher compute time. Then again, omitting these details might be desirable. It all depends on your definition of homoglyphs and your use case.</p><h2 id=seeing-further-confusable-characters>Seeing further: confusable characters</h2><p>I think it&rsquo;s pretty cool to:</p><ol><li>Be aware that homoglyphs are a thing.</li><li>Have a way to determine the homoglyphs of a given character.</li></ol><p>I became interested in homoglyphs because of my initial interest in what I call &ldquo;approximate homoglyphs&rdquo;. When I work with OCR outputs, it&rsquo;s often the case that a <code>0</code> gets interpreted as an <code>O</code>. These are different characters that look similar but are not rendered identically. I&rsquo;ve even seen an <code>O</code> get interpreted as a <code>.</code>, presumably because the human being who wrote the document had a small handwriting. Having a list of approximate homoglyphs for a given character would be useful for <a href=https://norvig.com/spell-correct.html>spelling correction</a>. Of course, I can build this list by hand, and that&rsquo;s what I&rsquo;ve been doing at my day job. But it would be nice to have an automated procedure to do so.</p><p>I&rsquo;ve stumbled on <a href=https://eprints.whiterose.ac.uk/112665/1/paper_247v2.pdf>this paper</a> which discusses how homoglyph detection can be used to uncover plagiarism. The paper mentions a <a href=https://util.unicode.org/UnicodeJsps/confusables.jsp>dataset</a> of confusable characters that the Unicode consortium has compiled. There&rsquo;s even some libraries out there that expose this dataset in a friendly manner, such as <a href=https://github.com/janlelis/unicode-confusable>this one for Ruby</a> and <a href=https://github.com/woodgern/confusables>this one for Python</a>. I&rsquo;ve also found some superb documentation <a href=https://websec.github.io/unicode-security-guide/visual-spoofing/>here</a> and <a href=http://www.unicode.org/reports/tr39/#Confusable_Detection>here</a>. I&rsquo;ll look into all this and report back at some point.</p><p><em>Meta: I don&rsquo;t think I would have written this blog post if I had first found out about the term &ldquo;confusable characters&rdquo;. This is not the first time this thing has happened to me: I get very curious about a topic, and I dig by myself into the topic because I can&rsquo;t find anything online. Then, I learn about the correct terminology, and realize that someone has already worked on the topic. The only moat keeping me from accessing this knowledge in the first place is the knowledge of the correct terminology. It never ceases to amaze me how knowing how things are called gives you a lot of power. I first became aware of this principle thanks to Patrick Winston: he calls this <a href=https://alum.mit.edu/slice/rumpelstiltskin-principle>The Rumpelstiltskin Principle</a>.</em></p></div><script type=text/javascript>var s=document.createElement("script");s.setAttribute("src","https://utteranc.es/client.js"),s.setAttribute("repo","MaxHalford/maxhalford.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",null),s.setAttribute("theme","github-light"),document.body.appendChild(s)</script><div style=display:flex;flex-direction:row;justify-content:center;align-items:center;gap:20px;margin-bottom:30px><div class=do-the-thing><div class=elevator><svg class="sweet-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" enable-background="new 0 0 100 100" height="100" width="100"><path d="M70 47.5H30c-1.4.0-2.5 1.1-2.5 2.5v40c0 1.4 1.1 2.5 2.5 2.5h40c1.4.0 2.5-1.1 2.5-2.5V50C72.5 48.6 71.4 47.5 70 47.5zm-22.5 40h-5v-25h5v25zm10 0h-5v-25h5v25zm10 0h-5V60c0-1.4-1.1-2.5-2.5-2.5H40c-1.4.0-2.5 1.1-2.5 2.5v27.5h-5v-35h35v35z"/><path d="M50 42.5c1.4.0 2.5-1.1 2.5-2.5V16l5.7 5.7c.5.5 1.1.7 1.8.7s1.3-.2 1.8-.7c1-1 1-2.6.0-3.5l-10-10c-1-1-2.6-1-3.5.0l-10 10c-1 1-1 2.6.0 3.5 1 1 2.6 1 3.5.0l5.7-5.7v24c0 1.4 1.1 2.5 2.5 2.5z"/></svg>Back to the top</div></div><iframe src=https://github.com/sponsors/MaxHalford/button title="Sponsor MaxHalford" height=32 width=114 style=border:0;border-radius:6px></iframe></div><script src=https://cdnjs.cloudflare.com/ajax/libs/elevator.js/1.0.1/elevator.min.js></script>
<script>var elementButton=document.querySelector(".elevator"),elevator=new Elevator({element:elementButton,mainAudio:"/music/elevator.mp3",endAudio:"/music/ding.mp3"})</script><style>.down-arrow{font-size:120px;margin-top:90px;margin-bottom:90px;text-shadow:0 -20px #0c1f31,0 0 #c33329;color:transparent;-webkit-transform:scaleY(.8);-moz-transform:scaleY(.8);transform:scaleY(.8)}.elevator{text-align:center;cursor:pointer;width:140px;margin:auto}.elevator:hover{opacity:.7}.elevator svg{width:40px;height:40px;display:block;margin:auto;margin-bottom:5px}</style><div class=related-content><h3 style=margin-top:10px!important;margin-bottom:10px!important>Related posts</h3><ul style=margin-top:0><li><a href=/blog/text-classification-by-compression/>Text classification by data compression</a></li><li><a href=/blog/sklearn-text-classifier-memory-footprint-reduction/>Reducing the memory footprint of a scikit-learn text classifier</a></li><li><a href=/blog/textract-table-to-pandas/>Converting Amazon Textract tables to pandas DataFrames</a></li></ul></div></div></div></article></body></html>