<!doctype html><html lang=en><head><script defer src=https://unpkg.com/@tinybirdco/flock.js data-host=https://api.tinybird.co data-token=p.eyJ1IjogImMwMjJhMjg1LWJmY2YtNDc0OC1hYzczLTJhMDQ1Njk3NTI0YyIsICJpZCI6ICIzNjc3NjQ3Ny04MTE2LTRmYWQtYjcwMy1iZmM3YjMwZGJjMjMifQ.A0vHm-VWbXG6uBFZiwuspN_AyfSYNrdZE3IgwgWSt4g></script><meta charset=utf-8><meta name=generator content="Hugo 0.117.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Max Halford"><meta property="og:url" content="https://maxhalford.github.io/blog/transitive-duplicates/"><link rel=canonical href=https://maxhalford.github.io/blog/transitive-duplicates/><meta property="og:title" content="Finding fuzzy duplicates with pandas"><meta property="og:description" content="Duplicate detection is the task of finding two or more instances in a dataset that are in fact identical. As an example, take the following toy dataset:
First name Last name Email 0 Erlich Bachman eb@piedpiper.com 1 Erlich Bachmann eb@piedpiper.com 2 Erlik Bachman eb@piedpiper.co 3 Erlich Bachmann eb@piedpiper.com Each of these instances (rows, if you prefer) corresponds to the same &ldquo;thing&rdquo; &ndash; note that I&rsquo;m not using the word &ldquo;entity&rdquo; because entity resolution is a different, and yet related, concept."><meta property="og:type" content="article"><meta property="og:url" content="https://maxhalford.github.io/blog/transitive-duplicates/"><meta property="og:image" content="https://maxhalford.github.io/img/beach.jpg"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-09-16T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-16T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://maxhalford.github.io/img/beach.jpg"><meta name=twitter:title content="Finding fuzzy duplicates with pandas"><meta name=twitter:description content="Duplicate detection is the task of finding two or more instances in a dataset that are in fact identical. As an example, take the following toy dataset:
First name Last name Email 0 Erlich Bachman eb@piedpiper.com 1 Erlich Bachmann eb@piedpiper.com 2 Erlik Bachman eb@piedpiper.co 3 Erlich Bachmann eb@piedpiper.com Each of these instances (rows, if you prefer) corresponds to the same &ldquo;thing&rdquo; &ndash; note that I&rsquo;m not using the word &ldquo;entity&rdquo; because entity resolution is a different, and yet related, concept."><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦”</text></svg>"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/maxhalford.github.io\/"},"articleSection":"blog","name":"Finding fuzzy duplicates with pandas","headline":"Finding fuzzy duplicates with pandas","description":"Duplicate detection is the task of finding two or more instances in a dataset that are in fact identical. As an example, take the following toy dataset:\nFirst name Last name Email 0 Erlich Bachman eb@piedpiper.com 1 Erlich Bachmann eb@piedpiper.com 2 Erlik Bachman eb@piedpiper.co 3 Erlich Bachmann eb@piedpiper.com Each of these instances (rows, if you prefer) corresponds to the same \u0026ldquo;thing\u0026rdquo; \u0026ndash; note that I\u0026rsquo;m not using the word \u0026ldquo;entity\u0026rdquo; because entity resolution is a different, and yet related, concept.","inLanguage":"en-US","author":"Max Halford","creator":"Max Halford","publisher":"Max Halford","accountablePerson":"Max Halford","copyrightHolder":"Max Halford","copyrightYear":"2019","datePublished":"2019-09-16 00:00:00 \u002b0000 UTC","dateModified":"2019-09-16 00:00:00 \u002b0000 UTC","url":"https:\/\/maxhalford.github.io\/blog\/transitive-duplicates\/","keywords":["data-eng"]}</script><title>Finding fuzzy duplicates with pandas â€¢ Max Halford</title><meta property="og:title" content="Finding fuzzy duplicates with pandas â€¢ Max Halford"><meta property="og:type" content="article"><meta name=description content="Duplicate detection is the task of finding two or more instances in a dataset that are in fact identical. As an example, take the following toy dataset:
First name Last name Email 0 Erlich Bachman eb@piedpiper.com 1 Erlich Bachmann eb@piedpiper.com 2 Erlik Bachman eb@piedpiper.co 3 Erlich Bachmann eb@piedpiper.com Each of these instances (rows, if you prefer) corresponds to the same &ldquo;thing&rdquo; &ndash; note that I&rsquo;m not using the word &ldquo;entity&rdquo; because entity resolution is a different, and yet related, concept."><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/highlight/github.css><link rel=stylesheet href=/css/index.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Permanent+Marker&display=swap" rel=stylesheet><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><article class=post id=article><div class="row center-xs" style=text-align:left><div class="col-xs-12 col-sm-10 col-md-7 col-lg-5"><div class=header><header class=header-parts><div class="signatures site-title"><a href=/>Max Halford ðŸ¦”</a></div><div class=header-links><a class=header-link href=/>Blog</a>
<a class=header-link href=/links/>Links</a>
<a class=header-link href=/bio/>Bio</a></div></header></div><header class=post-header><h1 class=post-title>Finding fuzzy duplicates with pandas</h1><div class="row post-desc"><div class="col-xs-12 post-desc-items"><time class=post-date datetime="2019-09-16 00:00:00 UTC">2019-09-16</time>
<span class=posts-line-tag>data-eng</span></div></div></header><div class="post-content markdown-body"><p>Duplicate detection is the task of finding two or more instances in a dataset that are in fact identical. As an example, take the following toy dataset:</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center><strong>First name</strong></th><th style=text-align:center><strong>Last name</strong></th><th style=text-align:center><strong>Email</strong></th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>Erlich</td><td style=text-align:center>Bachman</td><td style=text-align:center><a href=mailto:eb@piedpiper.com>eb@piedpiper.com</a></td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>Erlich</td><td style=text-align:center>Bachmann</td><td style=text-align:center><a href=mailto:eb@piedpiper.com>eb@piedpiper.com</a></td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>Erlik</td><td style=text-align:center>Bachman</td><td style=text-align:center><a href=mailto:eb@piedpiper.co>eb@piedpiper.co</a></td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>Erlich</td><td style=text-align:center>Bachmann</td><td style=text-align:center><a href=mailto:eb@piedpiper.com>eb@piedpiper.com</a></td></tr></tbody></table><p>Each of these instances (rows, if you prefer) corresponds to the same &ldquo;thing&rdquo; &ndash; note that I&rsquo;m not using the word &ldquo;entity&rdquo; because <a href=https://www.wikiwand.com/en/Record_linkage#/Entity_resolution>entity resolution</a> is a different, and yet related, concept. In my experience there are two main reasons why data duplication may occur:</p><ol><li>Somebody made a spelling mistake when entering data somewhere.</li><li>Some (very naughty) people create fake accounts to gain freebies for newly registered accounts.</li></ol><p>For a comprehensive review, I highly recommend <a href=https://epdf.pub/an-introduction-to-duplicate-detection.html>&ldquo;An Introduction to Duplicate Detection&rdquo;</a> by <a href="https://scholar.google.com/citations?user=Pqf21y0AAAAJ&amp;hl=en">Felix Naumann</a> and <a href="https://scholar.google.com/citations?user=K5VPw-IAAAAJ&amp;hl=en">Melanie Herschel</a>.</p><p>Note that in this case our notion of &ldquo;duplicate&rdquo; doesn&rsquo;t mean there is an exact match. On the contrary here we are interested in so-called <em>fuzzy duplicates</em> that &ldquo;look&rdquo; the same. In general we will have a function which tells us if yes or no two instances match. Here is an example using <a href=https://github.com/seatgeek/fuzzywuzzy>fuzzywuzzy</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>fuzzywuzzy</span> <span class=kn>import</span> <span class=n>fuzz</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_same_user</span><span class=p>(</span><span class=n>user_1</span><span class=p>,</span> <span class=n>user_2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fuzz</span><span class=o>.</span><span class=n>partial_ratio</span><span class=p>(</span><span class=n>user_1</span><span class=p>[</span><span class=s1>&#39;first_name&#39;</span><span class=p>],</span> <span class=n>user_2</span><span class=p>[</span><span class=s1>&#39;first_name&#39;</span><span class=p>])</span> <span class=o>&gt;</span> <span class=mi>90</span>
</span></span></code></pre></div><p>The matching function entirely depends on your application. There is no silver bullet that will work for each and every case. Note that nowadays some people are <a href=https://www.datarobot.com/use-cases/finding-duplicate-customer-records-database/>using machine learning</a> to find a good matching function. In this post I mostly want to talk about <em>how to search for duplicates</em>, given that a matching function has been established.</p><p>A little twist to duplicate detection is the notion of <em>transitive duplicates</em>. Suppose you have 3 instances A, B, and C. Your matching function finds that A matches B and that B matches C. The matching function did not find any match between A and C. However, by applying transitivity, we can see that A and C in fact match because they are linked by B. A and C are thus transitive duplicated. Finding transitive duplicates is straightforward but costly. Indeed, from what I have gleaned the standard way to proceed is as follows:</p><ol><li>Compare each combination of pairs of instances and check if they match.</li><li>Organize the pairs into an undirected graph.</li><li>Enumerate the connected subgraphs.</li></ol><p>To my surprise, I could not find any straightforward way to identify duplicates using Python&rsquo;s data science stack. Sure, <code>pandas</code> has a <a href=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.duplicated.html><code>.duplicated()</code> method</a>, but it seems that it only handles exact duplicates and not fuzzy duplicates. There is also the rather popular <a href=https://github.com/dedupeio/dedupe><code>dedupe</code> library</a>, but it looks overly complex. I thus decided to implement my own solution:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pandas</span> <span class=k>as</span> <span class=nn>pd</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_partitions</span><span class=p>(</span><span class=n>df</span><span class=p>,</span> <span class=n>match_func</span><span class=p>,</span> <span class=n>max_size</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>block_by</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Recursive algorithm for finding duplicates in a DataFrame.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># If block_by is provided, then we apply the algorithm to each block and</span>
</span></span><span class=line><span class=cl>    <span class=c1># stitch the results back together</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>block_by</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>blocks</span> <span class=o>=</span> <span class=n>df</span><span class=o>.</span><span class=n>groupby</span><span class=p>(</span><span class=n>block_by</span><span class=p>)</span><span class=o>.</span><span class=n>apply</span><span class=p>(</span><span class=k>lambda</span> <span class=n>g</span><span class=p>:</span> <span class=n>find_partitions</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>df</span><span class=o>=</span><span class=n>g</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>match_func</span><span class=o>=</span><span class=n>match_func</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>max_size</span><span class=o>=</span><span class=n>max_size</span>
</span></span><span class=line><span class=cl>        <span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>keys</span> <span class=o>=</span> <span class=n>blocks</span><span class=o>.</span><span class=n>index</span><span class=o>.</span><span class=n>unique</span><span class=p>(</span><span class=n>block_by</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>keys</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>keys</span><span class=p>[</span><span class=mi>1</span><span class=p>:]):</span>
</span></span><span class=line><span class=cl>            <span class=n>blocks</span><span class=o>.</span><span class=n>loc</span><span class=p>[</span><span class=n>b</span><span class=p>,</span> <span class=p>:]</span> <span class=o>+=</span> <span class=n>blocks</span><span class=o>.</span><span class=n>loc</span><span class=p>[</span><span class=n>a</span><span class=p>]</span><span class=o>.</span><span class=n>iloc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>blocks</span><span class=o>.</span><span class=n>reset_index</span><span class=p>(</span><span class=n>block_by</span><span class=p>,</span> <span class=n>drop</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_record_index</span><span class=p>(</span><span class=n>r</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>r</span><span class=p>[</span><span class=n>df</span><span class=o>.</span><span class=n>index</span><span class=o>.</span><span class=n>name</span> <span class=ow>or</span> <span class=s1>&#39;index&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Records are easier to work with than a DataFrame</span>
</span></span><span class=line><span class=cl>    <span class=n>records</span> <span class=o>=</span> <span class=n>df</span><span class=o>.</span><span class=n>to_records</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># This is where we store each partition</span>
</span></span><span class=line><span class=cl>    <span class=n>partitions</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>find_partition</span><span class=p>(</span><span class=n>at</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>partition</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>indexes</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>r1</span> <span class=o>=</span> <span class=n>records</span><span class=p>[</span><span class=n>at</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>partition</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>partition</span> <span class=o>=</span> <span class=p>{</span><span class=n>get_record_index</span><span class=p>(</span><span class=n>r1</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>            <span class=n>indexes</span> <span class=o>=</span> <span class=p>[</span><span class=n>at</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># Stop if enough duplicates have been found</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>max_size</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span> <span class=ow>and</span> <span class=nb>len</span><span class=p>(</span><span class=n>partition</span><span class=p>)</span> <span class=o>==</span> <span class=n>max_size</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>partition</span><span class=p>,</span> <span class=n>indexes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>r2</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>records</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>get_record_index</span><span class=p>(</span><span class=n>r2</span><span class=p>)</span> <span class=ow>in</span> <span class=n>partition</span> <span class=ow>or</span> <span class=n>i</span> <span class=o>==</span> <span class=n>at</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>match_func</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>partition</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>get_record_index</span><span class=p>(</span><span class=n>r2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>indexes</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>find_partition</span><span class=p>(</span><span class=n>at</span><span class=o>=</span><span class=n>i</span><span class=p>,</span> <span class=n>partition</span><span class=o>=</span><span class=n>partition</span><span class=p>,</span> <span class=n>indexes</span><span class=o>=</span><span class=n>indexes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>partition</span><span class=p>,</span> <span class=n>indexes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>records</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>partition</span><span class=p>,</span> <span class=n>indexes</span> <span class=o>=</span> <span class=n>find_partition</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>partitions</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>partition</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>records</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>delete</span><span class=p>(</span><span class=n>records</span><span class=p>,</span> <span class=n>indexes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>pd</span><span class=o>.</span><span class=n>Series</span><span class=p>({</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span><span class=p>:</span> <span class=n>partition_id</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>partition_id</span><span class=p>,</span> <span class=n>idxs</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>partitions</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>idx</span> <span class=ow>in</span> <span class=n>idxs</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span></code></pre></div><p>Admittedly, this is quite hard to take in by itself. I designed this algorithm during a Master&rsquo;s internship where I needed to find duplicates in an SQL table. When preparing this blog post, I realized that the algorithm was wrong and wouldn&rsquo;t work in one edge-case. I&rsquo;ve double-checked and now everything should work fine. The core of the algorithm happens in the <code>find_partition</code> function. The idea is to recursively expand a set of instances that match. The fact that two instances match is decided by the <code>match_func</code> parameter which has to be provided by the user. The algorithm returns a <code>pandas.Series</code> which contains integers that associate each index value with an entity identifier. I also added a few improvements of which I&rsquo;ll show the benefits further on:</p><ol><li>The <code>max_size</code> parameter can be used if you know how many times an instance can be duplicated at most.</li><li>The <code>block_by</code> parameter can be used if you know that duplicates can&rsquo;t occur between values of a given column.</li></ol><p>As an example, I&rsquo;ll be using the <a href=https://hpi.de/naumann/projects/repeatability/datasets/restaurants-dataset.html>restaurants dataset</a> from the Hasso Platner Institute &ndash; the place where Felix Naumann works. Here are the first five rows of the dataset:</p><table class=dataframe><thead><tr style=text-align:center;font-weight:700><th>id</th><th>address</th><th>city</th><th>name</th><th>phone</th><th>type</th></tr></thead><tbody><tr><th>1</th><td>435 s la cienega blv</td><td>los angeles</td><td>arnie morton s of chicago</td><td>310 246 1501</td><td>american</td></tr><tr><th>2</th><td>435 s la cienega blvd</td><td>los angeles</td><td>arnie morton s of chicago</td><td>310 246 1501</td><td>steakhouses</td></tr><tr><th>3</th><td>12224 ventura blvd</td><td>studio city</td><td>art s delicatessen</td><td>818 762 1221</td><td>american</td></tr><tr><th>4</th><td>12224 ventura blvd</td><td>studio city</td><td>art s deli</td><td>818 762 1221</td><td>delis</td></tr><tr><th>5</th><td>701 stone canyon rd</td><td>bel air</td><td>hotel bel air</td><td>310 472 1211</td><td>californian</td></tr></tbody></table><p>The dataset contains 864 instances, of which 112 are duplicates &ndash; the list of duplicates is also available from the website. It took me two hours to design a rule-based function which would tell me if yes or no two given restaurants were duplicates or not. Here goes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>fuzzywuzzy</span> <span class=kn>import</span> <span class=n>fuzz</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>same_phone</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>r1</span><span class=p>[</span><span class=s1>&#39;phone&#39;</span><span class=p>]</span> <span class=o>==</span> <span class=n>r2</span><span class=p>[</span><span class=s1>&#39;phone&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>same_area_code</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>r1</span><span class=p>[</span><span class=s1>&#39;phone&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39; &#39;</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>r2</span><span class=p>[</span><span class=s1>&#39;phone&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39; &#39;</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>same_name</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fuzz</span><span class=o>.</span><span class=n>ratio</span><span class=p>(</span><span class=n>r1</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>],</span> <span class=n>r2</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>])</span> <span class=o>&gt;</span> <span class=mi>75</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>similar_address</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>fuzz</span><span class=o>.</span><span class=n>ratio</span><span class=p>(</span><span class=n>r1</span><span class=p>[</span><span class=s1>&#39;address&#39;</span><span class=p>],</span> <span class=n>r2</span><span class=p>[</span><span class=s1>&#39;address&#39;</span><span class=p>])</span> <span class=o>&gt;</span> <span class=mi>55</span> <span class=ow>or</span>
</span></span><span class=line><span class=cl>        <span class=n>fuzz</span><span class=o>.</span><span class=n>partial_ratio</span><span class=p>(</span><span class=n>r1</span><span class=p>[</span><span class=s1>&#39;address&#39;</span><span class=p>],</span> <span class=n>r2</span><span class=p>[</span><span class=s1>&#39;address&#39;</span><span class=p>])</span> <span class=o>&gt;</span> <span class=mi>75</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>similar_name</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fuzz</span><span class=o>.</span><span class=n>partial_ratio</span><span class=p>(</span><span class=n>r1</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>],</span> <span class=n>r2</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>])</span> <span class=o>&gt;</span> <span class=mi>50</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>manual_ritz</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s1>&#39;ritz carlton&#39;</span> <span class=ow>in</span> <span class=n>r1</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>term</span> <span class=ow>in</span> <span class=p>[</span><span class=s1>&#39;cafe&#39;</span><span class=p>,</span> <span class=s1>&#39;dining room&#39;</span><span class=p>,</span> <span class=s1>&#39;restaurant&#39;</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>term</span> <span class=ow>in</span> <span class=n>r1</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>term</span> <span class=ow>in</span> <span class=n>r2</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>manual_le_marais</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=ow>not</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>r1</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;le marais&#39;</span> <span class=ow>and</span> <span class=n>r2</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;le madri&#39;</span> <span class=ow>or</span>
</span></span><span class=line><span class=cl>        <span class=n>r1</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;le madri&#39;</span> <span class=ow>and</span> <span class=n>r2</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;le marais&#39;</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>same_restaurant</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>same_phone</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>)</span> <span class=ow>and</span>
</span></span><span class=line><span class=cl>                <span class=n>similar_name</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span> <span class=ow>or</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>same_area_code</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>)</span> <span class=ow>and</span>
</span></span><span class=line><span class=cl>                <span class=n>same_name</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>)</span> <span class=ow>and</span>
</span></span><span class=line><span class=cl>                <span class=n>similar_address</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span> <span class=ow>and</span>
</span></span><span class=line><span class=cl>        <span class=n>manual_ritz</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>)</span> <span class=ow>and</span>
</span></span><span class=line><span class=cl>        <span class=n>manual_le_marais</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span></code></pre></div><p>I know, it&rsquo;s a bit of a mouthful, but it works perfectly and makes no mistakes. As I mentioned earlier, this blog post isn&rsquo;t about finding an appropriate matching function, but instead about how to apply the function in order to retrieve the duplicates. Here is how to run the algorithm on the restaurants dataset:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pandas</span> <span class=k>as</span> <span class=nn>pd</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>restaurants</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>read_csv</span><span class=p>(</span><span class=s1>&#39;restaurants/data.tsv&#39;</span><span class=p>,</span> <span class=n>sep</span><span class=o>=</span><span class=s1>&#39;</span><span class=se>\t</span><span class=s1>&#39;</span><span class=p>,</span> <span class=n>index_col</span><span class=o>=</span><span class=s1>&#39;id&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>restaurants</span><span class=p>[</span><span class=s1>&#39;real_id&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>find_partitions</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>df</span><span class=o>=</span><span class=n>restaurants</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>match_func</span><span class=o>=</span><span class=n>same_restaurant</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>Here is a subset of the result, using <code>restaurants.loc[33:38]</code>:</p><table class=dataframe><thead><tr style=text-align:center;font-weight:700><th>id</th><th>address</th><th>city</th><th>name</th><th>phone</th><th>type</th><th>real_id</th></tr></thead><tbody><tr><th>33</th><td>5955 melrose ave</td><td>los angeles</td><td>patina</td><td>213 467 1108</td><td>californian</td><td>16</td></tr><tr><th>34</th><td>5955 melrose ave</td><td>los angeles</td><td>patina</td><td>213 467 1108</td><td>californian</td><td>16</td></tr><tr><th>35</th><td>1001 n alameda st</td><td>los angeles</td><td>philippe s the original</td><td>213 628 3781</td><td>american</td><td>17</td></tr><tr><th>36</th><td>1001 n alameda st</td><td>chinatown</td><td>philippe the original</td><td>213 628 3781</td><td>cafeterias</td><td>17</td></tr><tr><th>37</th><td>12969 ventura blvd</td><td>los angeles</td><td>pinot bistro</td><td>818 990 0500</td><td>french</td><td>18</td></tr><tr><th>38</th><td>12969 ventura blvd</td><td>studio city</td><td>pinot bistro</td><td>818 990 0500</td><td>french bistro</td><td>18</td></tr></tbody></table><p>Note that finding the duplicates took around 8 seconds. Even though the dataset only contains 864 rows, a total of ${864 \choose 2} = 372,816$ comparisons have to be made in order to be exhaustive. However, as I mentioned there are two tricks I implemented which you can use. First, if you know in advance the number of times an instance can be duplicated, then you can tell the algorithm to stop searching once it has found said number of copies. In the restaurants example, it turns out that every duplicated restaurant is only duplicated once. In other word, each partition of duplicates is necessarily composed of just two elements. We can thus set the <code>max_size</code> parameter to 2 and hopefully shave off some time:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>restaurants</span><span class=p>[</span><span class=s1>&#39;real_id&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>find_partitions</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>df</span><span class=o>=</span><span class=n>restaurants</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>match_func</span><span class=o>=</span><span class=n>same_restaurant</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>max_size</span><span class=o>=</span><span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>This brings us down to 6 seconds, which means we saved 2 seconds. The second trick is to use a &ldquo;block key&rdquo; in order to reduce the number of comparisons even more. The insight is that some rules completely determine by themselves if two instances are <em>not</em> duplicates. Indeed, in this case the restaurants that are duplicated always have a phone number that begins with the same area code. In the USA, the area code is represented by the first three digits of the phone number. This means that we only have to search for duplicates within each block defined by each area code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>restaurants</span><span class=p>[</span><span class=s1>&#39;area_code&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>restaurants</span><span class=p>[</span><span class=s1>&#39;phone&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>str</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39; &#39;</span><span class=p>,</span> <span class=n>expand</span><span class=o>=</span><span class=kc>True</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>restaurants</span><span class=p>[</span><span class=s1>&#39;real_id&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>find_partitions</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>df</span><span class=o>=</span><span class=n>restaurants</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>match_func</span><span class=o>=</span><span class=n>same_restaurant</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>block_by</span><span class=o>=</span><span class=s1>&#39;area_code&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>max_size</span><span class=o>=</span><span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>This brings us down to 4 seconds, which is 50% times faster that the plain variant without any tricks. I checked and most of the remaining computation time is taken by <code>fuzzywuzzy</code> library. Designing a better matching function is probably the next step to take in order to get this to go any faster.</p><p>I hope you enjoyed this post. I apologize for going through the explanations a bit quickly. I mostly wrote this because I wasn&rsquo;t able to find anything that satisfied my needs online. Hopefully some other people will find useful for their own problems. Feel free to shoot me an email if you have any remarks and/or questions.</p></div><script type=text/javascript>var s=document.createElement("script");s.setAttribute("src","https://utteranc.es/client.js"),s.setAttribute("repo","MaxHalford/maxhalford.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",null),s.setAttribute("theme","github-light"),document.body.appendChild(s)</script><div style=display:flex;flex-direction:row;justify-content:center;align-items:center;gap:20px;margin-bottom:30px><div class=do-the-thing><div class=elevator><svg class="sweet-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" enable-background="new 0 0 100 100" height="100" width="100"><path d="M70 47.5H30c-1.4.0-2.5 1.1-2.5 2.5v40c0 1.4 1.1 2.5 2.5 2.5h40c1.4.0 2.5-1.1 2.5-2.5V50C72.5 48.6 71.4 47.5 70 47.5zm-22.5 40h-5v-25h5v25zm10 0h-5v-25h5v25zm10 0h-5V60c0-1.4-1.1-2.5-2.5-2.5H40c-1.4.0-2.5 1.1-2.5 2.5v27.5h-5v-35h35v35z"/><path d="M50 42.5c1.4.0 2.5-1.1 2.5-2.5V16l5.7 5.7c.5.5 1.1.7 1.8.7s1.3-.2 1.8-.7c1-1 1-2.6.0-3.5l-10-10c-1-1-2.6-1-3.5.0l-10 10c-1 1-1 2.6.0 3.5 1 1 2.6 1 3.5.0l5.7-5.7v24c0 1.4 1.1 2.5 2.5 2.5z"/></svg>Back to the top</div></div><iframe src=https://github.com/sponsors/MaxHalford/button title="Sponsor MaxHalford" height=32 width=114 style=border:0;border-radius:6px></iframe></div><script src=https://cdnjs.cloudflare.com/ajax/libs/elevator.js/1.0.1/elevator.min.js></script>
<script>var elementButton=document.querySelector(".elevator"),elevator=new Elevator({element:elementButton,mainAudio:"/music/elevator.mp3",endAudio:"/music/ding.mp3"})</script><style>.down-arrow{font-size:120px;margin-top:90px;margin-bottom:90px;text-shadow:0 -20px #0c1f31,0 0 #c33329;color:transparent;-webkit-transform:scaleY(.8);-moz-transform:scaleY(.8);transform:scaleY(.8)}.elevator{text-align:center;cursor:pointer;width:140px;margin:auto}.elevator:hover{opacity:.7}.elevator svg{width:40px;height:40px;display:block;margin:auto;margin-bottom:5px}</style><div class=related-content><h3 style=margin-top:10px!important;margin-bottom:10px!important>Related posts</h3><ul style=margin-top:0><li><a href=/blog/skyline-queries/>Skyline queries in Python</a></li><li><a href=/blog/machine-learning-production/>A smooth approach to putting machine learning into production</a></li></ul></div></div></div></article></body></html>