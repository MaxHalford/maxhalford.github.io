<!doctype html><html lang=en><head><script async defer data-website-id=6023252a-3a97-470f-b4ee-5082d242bb9a src=https://umami.pourtan.eu/umami.js></script><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Max Halford"><meta property="og:url" content="https://maxhalford.github.io/blog/flask-sse-no-deps/"><link rel=canonical href=https://maxhalford.github.io/blog/flask-sse-no-deps/><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦”</text></svg>"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/maxhalford.github.io\/"},"articleSection":"blog","name":"Server-sent events in Flask without extra dependencies","headline":"Server-sent events in Flask without extra dependencies","description":"Server-sent events (SSE) is a mechanism for sending updates from a server to a client. The fundamental difference with WebSockets is that the communication only goes in one direction. In other words, the client cannot send information to the server. For many usecases this is all you might need. Indeed, if you just want to receive notifications\/updates\/messages, then using a WebSocket is overkill. Once you\u0026rsquo;ve implemented the SSE functionality on your server, then all you need on a JavaScript client is an EventSource.","inLanguage":"en-US","author":"Max Halford","creator":"Max Halford","publisher":"Max Halford","accountablePerson":"Max Halford","copyrightHolder":"Max Halford","copyrightYear":"2020","datePublished":"2020-05-04 00:00:00 \u002b0000 UTC","dateModified":"2020-05-04 00:00:00 \u002b0000 UTC","url":"https:\/\/maxhalford.github.io\/blog\/flask-sse-no-deps\/","keywords":["web-dev"]}</script><title>Server-sent events in Flask without extra dependencies â€¢ Max Halford</title><meta property="og:title" content="Server-sent events in Flask without extra dependencies â€¢ Max Halford"><meta property="og:type" content="article"><meta name=description content="Server-sent events (SSE) is a mechanism for sending updates from a server to a client. The fundamental difference with WebSockets is that the communication only goes in one direction. In other words, the client cannot send information to the server. For many usecases this is all you might need. Indeed, if you just want to receive notifications/updates/messages, then using a WebSocket is overkill. Once you&rsquo;ve implemented the SSE functionality on your server, then all you need on a JavaScript client is an EventSource."><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/highlight/github.css><link rel=stylesheet href=/css/index.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Permanent+Marker&display=swap" rel=stylesheet><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><article class=post id=article><div class="row center-xs" style=text-align:left><div class="col-xs-12 col-sm-10 col-md-7 col-lg-5"><div class=header><header class=header-parts><div class="signatures site-title"><a href=/>Max Halford ðŸ¦”</a></div><div class=header-links><a class=header-link href=/>Blog</a>
<a class=header-link href=/links/>Links</a>
<a class=header-link href=/bio/>Bio</a></div></header></div><header class=post-header><h1 class=post-title>Server-sent events in Flask without extra dependencies</h1><div class="row post-desc"><div class="col-xs-12 post-desc-items"><time class=post-date datetime="2020-05-04 00:00:00 UTC">2020-05-04</time>
<span class=posts-line-tag>web-dev</span></div></div></header><div class="post-content markdown-body"><p><a href=https://www.wikiwand.com/en/Server-sent_events>Server-sent events (SSE)</a> is a mechanism for sending updates from a server to a client. The fundamental difference with <a href=https://www.wikiwand.com/en/WebSocket>WebSockets</a> is that the communication only goes in one direction. In other words, the client cannot send information to the server. For many usecases this is all you might need. Indeed, if you just want to receive notifications/updates/messages, then using a WebSocket is overkill. Once you&rsquo;ve implemented the SSE functionality on your server, then all you need on a JavaScript client is an <a href=https://developer.mozilla.org/en-US/docs/Web/API/EventSource><code>EventSource</code></a>. Trust me, it&rsquo;s very straightforward.</p><p>I am first and foremost a data scientist, and therefore don&rsquo;t consider myself to be an expert in web technologies. I came across the SSE protocol because I wanted to implement a notification system for a <a href=https://github.com/creme-ml/chantilly>machine learning deployment tool</a> I&rsquo;m working on. The tool uses Flask, and so I stumbled on the <a href=https://github.com/singingwolfboy/flask-sse><code>flask-sse</code></a> package. It looks great, but it requires using Redis. I like Redis, but I don&rsquo;t like the idea of having to add a new dependency to my application for implementing a single feature. If I was the only person that was going to use the application, then I would be fine with it. However, the application I&rsquo;m building is destined to be distributed as a package, and therefore I don&rsquo;t want to coerce users into installing Redis.</p><p>The <code>flask-sse</code> package requires having Redis installed because it needs a storage backend with implements the <a href=https://www.wikiwand.com/en/Publish%E2%80%93subscribe_pattern>publish-subscribe pattern</a> &ndash; which is commonly abbreviated to &ldquo;pubsub&rdquo;. The idea of this pattern is that messages are not directly sent to listeners. Instead, a message is sent to a middleware who&rsquo;s responsibility is to relay the message to the listeners. The advantage is that the message emitter doesn&rsquo;t have to worry about the details. In particular, it doesn&rsquo;t have to check that the message gets dispatched correctly. These concerns are rather delegated to the middleware. There are many great implementations that can take charge of this for you, including Redis. However, if you&rsquo;re not too concerned about performance, then you can easily do this yourself in Flask without any extra dependencies. Let me demonstrate.</p><p>To start off, I&rsquo;m going to create a file named <code>app.py</code> which will contain all the Flask server logic.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>flask</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>flask</span><span class=o>.</span><span class=n>Flask</span><span class=p>(</span><span class=vm>__name__</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s1>&#39;/&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>hello_world</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s1>&#39;Hello, World!&#39;</span>
</span></span></code></pre></div><p>In order to implement the pubsub pattern, I&rsquo;m going to define a <code>MessageAnnouncer</code> class.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>queue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MessageAnnouncer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>listeners</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>listen</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>q</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>Queue</span><span class=p>(</span><span class=n>maxsize</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>listeners</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>q</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>q</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>announce</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>msg</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>reversed</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>listeners</span><span class=p>))):</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>listeners</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>put_nowait</span><span class=p>(</span><span class=n>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>except</span> <span class=n>queue</span><span class=o>.</span><span class=n>Full</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>del</span> <span class=bp>self</span><span class=o>.</span><span class=n>listeners</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span></code></pre></div><p>As you can see, <code>MessageAnnouncer</code> has two methods. The first one, which is <code>listen</code>, will be called by clients when they want to receive a notification every time something new happens. When a client starts listening, we simply append a <a href=https://docs.python.org/3/library/queue.html#queue.Queue><code>queue.Queue</code></a> to the list of listeners. The <code>queue</code> module is part of Python&rsquo;s standard library; it has the desirable property of being thread-safe by implementing locking mechanisms under the hood.</p><p>The second method of <code>MessageAnnouncer</code> is <code>announce</code>. It&rsquo;s responsability is to take an input message and dispatch it to every listener. Additionally, it removes listeners that don&rsquo;t &ldquo;seem&rdquo; to be listening anymore. By this I mean that if a message queue is full, then it&rsquo;s probably because the queue isn&rsquo;t being read from anymore. In the <code>listen</code> method, the maximum size of each queue is set to 5, which should give ample time to read a message before the next one arrives. If we set the maximum size to 1, then a queue might potentially be full because the associated listener doesn&rsquo;t have enough time to read each message before the next one arrives. Therefore, increasing the size of the queue gives some leeway so that rapid bursts of notifications don&rsquo;t clog the message queue. Note that we loop in reverse order because deleting a listener will affect the index values of all subsequent listeners.</p><p>Now for the easy part, which is to use the <code>MessageAnnouncer</code>. The first step is to instantiate it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>announcer</span> <span class=o>=</span> <span class=n>MessageAnnouncer</span><span class=p>()</span>
</span></span></code></pre></div><p>We&rsquo;ll only be using one <code>MessageAnnouncer</code> for the purpose of this example, but in practice you can use as many as you like. For instance, you could create one instance for each user you might have. But let&rsquo;s not disgress. Now, in order to implement the SSE protocol, we need to send events that follow a certain format. This format is slightly obscure, but is quite well described <a href=https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format>here</a>. Here is an example of what each message should look like:</p><pre tabindex=0><code>event: Jackson 5\\ndata: {&#34;abc&#34;: 123}\\n\\n
</code></pre><p>The carriage returns are important because they delimitate the beginnings and ends of consecutive messages. Here is little helper function to format a message to follow this convention:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=k>def</span> <span class=nf>format_sse</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>event</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>msg</span> <span class=o>=</span> <span class=sa>f</span><span class=s1>&#39;data: </span><span class=si>{</span><span class=n>data</span><span class=si>}</span><span class=se>\n\n</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>event</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>msg</span> <span class=o>=</span> <span class=sa>f</span><span class=s1>&#39;event: </span><span class=si>{</span><span class=n>event</span><span class=si>}</span><span class=se>\n</span><span class=si>{</span><span class=n>msg</span><span class=si>}</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>msg</span>
</span></span></code></pre></div><p>The <code>event</code> parameter is optional, it allows defining topics to which clients can subscribe to. This avoids having to define one message queue for each topic. We can now send messages to our message announcer, which will in turn take of dispatching them. Let&rsquo;s create a <code>/ping</code> route which does just that.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s1>&#39;/ping&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>ping</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>msg</span> <span class=o>=</span> <span class=n>format_sse</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=s1>&#39;pong&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>announcer</span><span class=o>.</span><span class=n>announce</span><span class=p>(</span><span class=n>msg</span><span class=o>=</span><span class=n>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{},</span> <span class=mi>200</span>
</span></span></code></pre></div><p>Because we&rsquo;re using the correct message format, these messages should property get received by any decently written client function. However, we first have to define a <code>/listen</code> route that allows listeners to subscribe in order to receive messages. Here goes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s1>&#39;/listen&#39;</span><span class=p>,</span> <span class=n>methods</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;GET&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>listen</span><span class=p>():</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>stream</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>messages</span> <span class=o>=</span> <span class=n>announcer</span><span class=o>.</span><span class=n>listen</span><span class=p>()</span>  <span class=c1># returns a queue.Queue</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>msg</span> <span class=o>=</span> <span class=n>messages</span><span class=o>.</span><span class=n>get</span><span class=p>()</span>  <span class=c1># blocks until a new message arrives</span>
</span></span><span class=line><span class=cl>            <span class=k>yield</span> <span class=n>msg</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>flask</span><span class=o>.</span><span class=n>Response</span><span class=p>(</span><span class=n>stream</span><span class=p>(),</span> <span class=n>mimetype</span><span class=o>=</span><span class=s1>&#39;text/event-stream&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>The previous is a bit esoteric because it&rsquo;s not common to return a function in a Flask response. However, this pattern is <a href=https://flask.palletsprojects.com/en/1.1.x/patterns/streaming/>quite well documented</a> and works as intended. Effectively, sending a <code>GET</code> request to the <code>/listen</code> route results in a response that takes an infinite amount of time. The <code>messages.get()</code> call blocks until a new message is put into the queue. Once a message arrives, it is sent through the HTTP connection in progress. The important thing to understand is that this response will never terminate, and thus will hang forever. Consequently, if you&rsquo;re running Flask with a single process, then it will block forever. Therefore, you need to make sure you&rsquo;re using Flask in threaded mode &ndash; which is done by default in recent versions. Moreover, if you&rsquo;re going to use a WSGI server other than Flask&rsquo;s default one, such as <a href=https://gunicorn.org/>Gunicorn</a>, then you need to make sure you&rsquo;re asynchronous workers. For example, in Gunicorn, this can be one setting the <a href=https://docs.gunicorn.org/en/stable/settings.html#worker-class><code>worker_class</code></a> parameter to something else than <code>'sync'</code>.</p><p>We may now run the server:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>export</span> <span class=nv>FLASK_APP</span><span class=o>=</span>app.py
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>FLASK_ENV</span><span class=o>=</span>development
</span></span><span class=line><span class=cl>flask run
</span></span></code></pre></div><p>In a separate terminal session, we can run a <code>listen.py</code> script which will subscribe to the <code>/listen</code> route. We can do this with the <a href=https://pypi.org/project/sseclient/><code>sseclient</code></a> library, which is a thin wrapper on top of <a href=https://requests.readthedocs.io/en/master/><code>requests</code></a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sseclient</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>messages</span> <span class=o>=</span> <span class=n>sseclient</span><span class=o>.</span><span class=n>SSEClient</span><span class=p>(</span><span class=s1>&#39;http://localhost:5000/listen&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>msg</span> <span class=ow>in</span> <span class=n>messages</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>msg</span><span class=p>)</span>
</span></span></code></pre></div><p>Finally, we can use a third terminal session to run another script which will call the <code>/ping</code> route once every second:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>requests</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>requests</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;http://localhost:5000/ping&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>You should now see a steady stream of <code>pong</code> messages in the terminal where the <code>listen.py</code> script is being ran. That&rsquo;s it, you&rsquo;re done! You can find a copy of these instructions along with the code in <a href=https://github.com/MaxHalford/flask-sse-no-deps>the accompaying GitHub repository</a>.</p><p>There&rsquo;s probably some room improvement. For instance, it would be nice to perform the event emission with <a href=https://flask.palletsprojects.com/en/1.1.x/signals/>Flask signals</a>, but I haven&rsquo;t been able to make it work yet. Additionally, I&rsquo;m not 100% how to make this work seamlessly behind a reverse proxy such as <a href=https://www.nginx.com/>Nginx</a>. Indeed, it seems that there are some <a href=https://serverfault.com/questions/801628/for-server-sent-events-sse-what-nginx-proxy-configuration-is-appropriate>specific settings</a> that have to be configured because of the long polling nature of the listening routes. Nonetheless, this implementation has been working quite well for me. Plus, I like the fact that it&rsquo;s a standalone solution. However, there might be some subtlety that I have missed and that would justify using something like Redis, in which case I would love some feedback.</p></div><script type=text/javascript>var s=document.createElement("script");s.setAttribute("src","https://utteranc.es/client.js"),s.setAttribute("repo","MaxHalford/maxhalford.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",null),s.setAttribute("theme","github-light"),document.body.appendChild(s)</script><div class=footer><div class=do-the-thing><div class=elevator><svg class="sweet-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" enable-background="new 0 0 100 100" height="100" width="100"><path d="M70 47.5H30c-1.4.0-2.5 1.1-2.5 2.5v40c0 1.4 1.1 2.5 2.5 2.5h40c1.4.0 2.5-1.1 2.5-2.5V50C72.5 48.6 71.4 47.5 70 47.5zm-22.5 40h-5v-25h5v25zm10 0h-5v-25h5v25zm10 0h-5V60c0-1.4-1.1-2.5-2.5-2.5H40c-1.4.0-2.5 1.1-2.5 2.5v27.5h-5v-35h35v35z"/><path d="M50 42.5c1.4.0 2.5-1.1 2.5-2.5V16l5.7 5.7c.5.5 1.1.7 1.8.7s1.3-.2 1.8-.7c1-1 1-2.6.0-3.5l-10-10c-1-1-2.6-1-3.5.0l-10 10c-1 1-1 2.6.0 3.5 1 1 2.6 1 3.5.0l5.7-5.7v24c0 1.4 1.1 2.5 2.5 2.5z"/></svg>Back to the top</div></div></div><script src=https://cdnjs.cloudflare.com/ajax/libs/elevator.js/1.0.1/elevator.min.js></script>
<script>var elementButton=document.querySelector(".elevator"),elevator=new Elevator({element:elementButton,mainAudio:"/music/elevator.mp3",endAudio:"/music/ding.mp3"})</script><style>.down-arrow{font-size:120px;margin-top:90px;margin-bottom:90px;text-shadow:0 -20px #0c1f31,0 0 #c33329;color:transparent;-webkit-transform:scaleY(.8);-moz-transform:scaleY(.8);transform:scaleY(.8)}.elevator{text-align:center;cursor:pointer;width:140px;margin:auto;margin-bottom:30px}.elevator:hover{opacity:.7}.elevator svg{width:40px;height:40px;display:block;margin:auto;margin-bottom:5px}</style><div class=related-content><h3 style=margin-top:10px!important;margin-bottom:10px!important>Related posts</h3><ul style=margin-top:0><li><a href=/blog/flask-droplet/>Setting up a droplet to host a Flask app</a></li></ul></div></div></div></article><script></script></body></html>