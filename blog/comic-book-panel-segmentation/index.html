<!doctype html><html lang=en><head><script defer src=https://unpkg.com/@tinybirdco/flock.js data-host=https://api.tinybird.co data-token=p.eyJ1IjogImMwMjJhMjg1LWJmY2YtNDc0OC1hYzczLTJhMDQ1Njk3NTI0YyIsICJpZCI6ICIzNjc3NjQ3Ny04MTE2LTRmYWQtYjcwMy1iZmM3YjMwZGJjMjMifQ.A0vHm-VWbXG6uBFZiwuspN_AyfSYNrdZE3IgwgWSt4g></script><meta charset=utf-8><meta name=generator content="Hugo 0.123.7"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Max Halford"><meta property="og:url" content="https://maxhalford.github.io/blog/comic-book-panel-segmentation/"><link rel=canonical href=https://maxhalford.github.io/blog/comic-book-panel-segmentation/><meta property="og:title" content="Comic book panel segmentation"><meta property="og:description" content="Edit (2023-05-26) &ndash; I&rsquo;ve learnt about the Kumiko project, which is exactly devoted to slicing comic book panels. There&rsquo;s even a live tool. I discovered it thanks to being pinged on this issue.
Motivation I&rsquo;ve recently been reading some comic books I used to devour as a kid. Especially those from the golden era of francophone comics: Thorgal, Lanfeust, XIII, Tintin, Largo Winch, Blacksad, Aldebaran, etc.
It&rsquo;s not easy to get my hands on many of them."><meta property="og:type" content="article"><meta property="og:url" content="https://maxhalford.github.io/blog/comic-book-panel-segmentation/"><meta property="og:image" content="https://maxhalford.github.io/img/belle-ile.jpg"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-03-05T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-05T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://maxhalford.github.io/img/belle-ile.jpg"><meta name=twitter:title content="Comic book panel segmentation"><meta name=twitter:description content="Edit (2023-05-26) &ndash; I&rsquo;ve learnt about the Kumiko project, which is exactly devoted to slicing comic book panels. There&rsquo;s even a live tool. I discovered it thanks to being pinged on this issue.
Motivation I&rsquo;ve recently been reading some comic books I used to devour as a kid. Especially those from the golden era of francophone comics: Thorgal, Lanfeust, XIII, Tintin, Largo Winch, Blacksad, Aldebaran, etc.
It&rsquo;s not easy to get my hands on many of them."><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦†</text></svg>"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/maxhalford.github.io\/"},"articleSection":"blog","name":"Comic book panel segmentation","headline":"Comic book panel segmentation","description":"Edit (2023-05-26) \u0026ndash; I\u0026rsquo;ve learnt about the Kumiko project, which is exactly devoted to slicing comic book panels. There\u0026rsquo;s even a live tool. I discovered it thanks to being pinged on this issue.\nMotivation I\u0026rsquo;ve recently been reading some comic books I used to devour as a kid. Especially those from the golden era of francophone comics: Thorgal, Lanfeust, XIII, Tintin, Largo Winch, Blacksad, Aldebaran, etc.\nIt\u0026rsquo;s not easy to get my hands on many of them.","inLanguage":"en-US","author":"Max Halford","creator":"Max Halford","publisher":"Max Halford","accountablePerson":"Max Halford","copyrightHolder":"Max Halford","copyrightYear":"2022","datePublished":"2022-03-05 00:00:00 \u002b0000 UTC","dateModified":"2022-03-05 00:00:00 \u002b0000 UTC","url":"https:\/\/maxhalford.github.io\/blog\/comic-book-panel-segmentation\/","keywords":["image-processing"]}</script><title>Comic book panel segmentation â€¢ Max Halford</title>
<meta property="og:title" content="Comic book panel segmentation â€¢ Max Halford"><meta property="og:type" content="article"><meta name=description content="Edit (2023-05-26) &ndash; I&rsquo;ve learnt about the Kumiko project, which is exactly devoted to slicing comic book panels. There&rsquo;s even a live tool. I discovered it thanks to being pinged on this issue.
Motivation I&rsquo;ve recently been reading some comic books I used to devour as a kid. Especially those from the golden era of francophone comics: Thorgal, Lanfeust, XIII, Tintin, Largo Winch, Blacksad, Aldebaran, etc.
It&rsquo;s not easy to get my hands on many of them."><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/highlight/github.css><link rel=stylesheet href=/css/index.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Permanent+Marker&display=swap" rel=stylesheet><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><article class=post id=article><div class="row center-xs" style=text-align:left><div class="col-xs-12 col-sm-10 col-md-7 col-lg-5"><div class=header><header class=header-parts><div class="signatures site-title"><a href=/>Max Halford ðŸ¦†</a></div><div class=header-links><a class=header-link href=/>Blog</a>
<a class=header-link href=/links/>Links</a>
<a class=header-link href=/bio/>Bio</a></div></header></div><header class=post-header><h1 class=post-title>Comic book panel segmentation</h1><div class="row post-desc"><div class="col-xs-12 post-desc-items"><time class=post-date datetime="2022-03-05 00:00:00 UTC">2022-03-05
</time><span class=posts-line-tag>image-processing</span></div></div></header><div class="post-content markdown-body"><h2 id=toc>Table of contents</h2><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#loading-an-image>Loading an image</a></li><li><a href=#canny-edge-detection>Canny edge detection</a></li><li><a href=#edge-thickening-via-dilation>Edge thickening via dilation</a></li><li><a href=#filling-holes>Filling holes</a></li><li><a href=#labelling-each-patch>Labelling each patch</a></li><li><a href=#regrouping-patches-into-panels>Regrouping patches into panels</a></li><li><a href=#ordering-the-panels>Ordering the panels</a></li><li><a href=#edge-cases>Edge cases</a></li><li><a href=#further-reading>Further reading</a></li></ul></nav><p><strong>Edit (2023-05-26)</strong> &ndash; <em>I&rsquo;ve learnt about the <a href=https://github.com/njean42/kumiko>Kumiko project</a>, which is exactly devoted to slicing comic book panels. There&rsquo;s even a live <a href=https://kumiko.njean.me/demo>tool</a>. I discovered it thanks to being pinged on <a href=https://github.com/njean42/kumiko/issues/12>this</a> issue.</em></p><h2 id=motivation>Motivation</h2><p>I&rsquo;ve recently been reading some comic books I used to devour as a kid. Especially those from the golden era of francophone comics: Thorgal, Lanfeust, XIII, Tintin, Largo Winch, Blacksad, Aldebaran, etc.</p><p>It&rsquo;s not easy to get my hands on many of them. Luckily enough I found a website called <a href=https://readcomiconline.li/>ReadComicOnline</a> which is delightfully profuse. It gives access to comics for free under the murky &ldquo;fair use&rdquo; copyright doctrine. I&rsquo;m very doubtful about the legality of the website, but I&rsquo;m still using it for lack of a better option.</p><p>I usually read these comics on my laptop. Reading them on my phone is not very convenient. I have to zoom in and move too many times to go from one panel to the next. I was thinking it might be easier if I could tap the screen to go from one panel to the next. That seems possible if the panels were cut up in pieces. It occurred to me that cutting up comic strip panels boils down to an image segmentation task.</p><p>I decided to have a go and write some Python code to segment a comic strip page. I thought it would be nice to document the steps I took. In particular, I made heavy use of <a href=https://scikit-image.org/>scikit-image</a>; so you could say this blog post is a tutorial on doing image segmentation with scikit-image.</p><h2 id=loading-an-image>Loading an image</h2><p>I&rsquo;m taking as an example the first page of <a href="https://readcomiconline.li/Comic/Thorgal/Issue-11?id=73734#1">The Invisible Fortress</a>, which is the 11th installment in the <a href=https://www.wikiwand.com/en/Thorgal>Thorgal</a> series.</p><p>I don&rsquo;t know what is the <em>goÃ»t du jour</em>, but I like using <a href=https://imageio.readthedocs.io/en/stable/>imageio</a> for loading images. I use <a href=https://pillow.readthedocs.io/en/stable/reference/Image.html>PIL</a> for displaying them in a Jupyter notebook.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>PIL</span> <span class=kn>import</span> <span class=n>Image</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>imageio</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>im</span> <span class=o>=</span> <span class=n>imageio</span><span class=o>.</span><span class=n>imread</span><span class=p>(</span><span class=s1>&#39;RCO003_1468214847.jpg&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>Image</span><span class=o>.</span><span class=n>fromarray</span><span class=p>(</span><span class=n>im</span><span class=p>)</span>
</span></span></code></pre></div><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/original.jpg></figure></div><h2 id=canny-edge-detection>Canny edge detection</h2><p>There are many ways to do image segmentation. It&rsquo;s an entire field of research. In the present case, it seemed to me that I should make use of the fact that each panel has some sort of border around it. The background of the page is also always made up of a single tone of white.</p><p>I did a bit of research and experimenting and settled on using a <a href=https://www.wikiwand.com/en/Canny_edge_detector>Canny edge detector</a>. I have absolutely no clue how it works, but I had a feeling that looking for the edges of the panels was the way to go. This detector works on grayscale images, so I first did the conversion.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.color</span> <span class=kn>import</span> <span class=n>rgb2gray</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>grayscale</span> <span class=o>=</span> <span class=n>rgb2gray</span><span class=p>(</span><span class=n>im</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>Image</span><span class=o>.</span><span class=n>fromarray</span><span class=p>((</span><span class=n>grayscale</span> <span class=o>*</span> <span class=mi>255</span><span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=s1>&#39;uint8&#39;</span><span class=p>),</span> <span class=s1>&#39;L&#39;</span><span class=p>)</span>
</span></span></code></pre></div><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/grayscale.png></figure></div><p>Applying a Canny edge detector is trivial with scikit-image.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.feature</span> <span class=kn>import</span> <span class=n>canny</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edges</span> <span class=o>=</span> <span class=n>canny</span><span class=p>(</span><span class=n>grayscale</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>Image</span><span class=o>.</span><span class=n>fromarray</span><span class=p>(</span><span class=n>edges</span><span class=p>)</span>
</span></span></code></pre></div><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/edges.png></figure></div><h2 id=edge-thickening-via-dilation>Edge thickening via dilation</h2><p>To make the segmentation process more robust, I decided to thicken the edges so that the lines along each panel&rsquo;s border are contiguous. Indeed, these panel borders are sometimes a bit rough, so it&rsquo;s possible that background pixels insert themselves. Thickening the output of the edge detector is a cheap way to make the ensuing segmentation process more robust. This can be done with a <a href=https://www.wikiwand.com/en/Dilation_(morphology)>dilation</a> operator.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.morphology</span> <span class=kn>import</span> <span class=n>dilation</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>thick_edges</span> <span class=o>=</span> <span class=n>dilation</span><span class=p>(</span><span class=n>dilation</span><span class=p>(</span><span class=n>edges</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>Image</span><span class=o>.</span><span class=n>fromarray</span><span class=p>(</span><span class=n>thick_edges</span><span class=p>)</span>
</span></span></code></pre></div><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/thick_edges.png></figure></div><h2 id=filling-holes>Filling holes</h2><p>There&rsquo;s still a few steps to take to get to where we want. But the heavy lifting has been done by the Canny edge detector. Now it&rsquo;s just a question of connecting the right parts of the image together.</p><p>First of all, I filled in all the black patches which are surrounded by white. This significantly reduces the number of contiguous patches of white pixels.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scipy</span> <span class=kn>import</span> <span class=n>ndimage</span> <span class=k>as</span> <span class=n>ndi</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>segmentation</span> <span class=o>=</span> <span class=n>ndi</span><span class=o>.</span><span class=n>binary_fill_holes</span><span class=p>(</span><span class=n>thick_edges</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>Image</span><span class=o>.</span><span class=n>fromarray</span><span class=p>(</span><span class=n>segmentation</span><span class=p>)</span>
</span></span></code></pre></div><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/segmentation.png></figure></div><p>With hindsight, I don&rsquo;t think this step is essential. But it feels right, and probably saves up some computation for the next steps.</p><h2 id=labelling-each-patch>Labelling each patch</h2><p>The next step is to label each white patch. Again, this is really easy to do thanks to scikit-image. There&rsquo;s even a nifty <code>label2rgb</code> function to help visualize the patches.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.measure</span> <span class=kn>import</span> <span class=n>label</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.color</span> <span class=kn>import</span> <span class=n>label2rgb</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>labels</span> <span class=o>=</span> <span class=n>label</span><span class=p>(</span><span class=n>segmentation</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Image</span><span class=o>.</span><span class=n>fromarray</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>uint8</span><span class=p>(</span><span class=n>label2rgb</span><span class=p>(</span><span class=n>labels</span><span class=p>,</span> <span class=n>bg_label</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>255</span><span class=p>))</span>
</span></span></code></pre></div><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/labels.png></figure></div><h2 id=regrouping-patches-into-panels>Regrouping patches into panels</h2><p>Up to here, I&rsquo;ve essentially been using scikit-image&rsquo;s out-of-the-box features. But the next step is a bit more involved. Essentially, my goal is to regroup the patches, so that patches which belong to the same panel are merged with each other. I didn&rsquo;t find any out-of-the-box way to do this, so I wrote my own logic.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>skimage.measure</span> <span class=kn>import</span> <span class=n>regionprops</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>do_bboxes_overlap</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=ow>and</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=ow>and</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=ow>and</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_bboxes</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=nb>min</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>b</span><span class=p>[</span><span class=mi>0</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>        <span class=nb>min</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>b</span><span class=p>[</span><span class=mi>1</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>        <span class=nb>max</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>b</span><span class=p>[</span><span class=mi>2</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>        <span class=nb>max</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=mi>3</span><span class=p>],</span> <span class=n>b</span><span class=p>[</span><span class=mi>3</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>regions</span> <span class=o>=</span> <span class=n>regionprops</span><span class=p>(</span><span class=n>labels</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>panels</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>region</span> <span class=ow>in</span> <span class=n>regions</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>panel</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>panels</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>do_bboxes_overlap</span><span class=p>(</span><span class=n>region</span><span class=o>.</span><span class=n>bbox</span><span class=p>,</span> <span class=n>panel</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>panels</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>merge_bboxes</span><span class=p>(</span><span class=n>panel</span><span class=p>,</span> <span class=n>region</span><span class=o>.</span><span class=n>bbox</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>panels</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>region</span><span class=o>.</span><span class=n>bbox</span><span class=p>)</span>
</span></span></code></pre></div><p>The <a href=https://scikit-image.org/docs/dev/api/skimage.measure.html#skimage.measure.regionprops><code>regionprops</code></a> function is handy, as it transforms a labelled image into a list of <a href=https://scikit-image.org/docs/dev/auto_examples/segmentation/plot_label.html>image regions</a>. These provide a <code>bbox</code> attribute, which is the bounding box encompassing a patch.</p><p>In a nutshell, the above logic is a clustering algorithm, whereby regions that have overlapping bounding boxes are merged. I found <a href=https://silentmatt.com/rectangle-intersection/>this great animation</a> which makes clear the logic for determining whether or not two rectangles overlap each other.</p><p>Afterwards, I did a little post-processing step to remove small panels. Indeed, if you look at the image above, the page number &ldquo;3&rdquo; is a separate region. And sometimes some printing artifacts may appear on a comic book page. I simply removed bounding boxes which are smaller than 1% of the image area.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>bbox</span> <span class=ow>in</span> <span class=nb>reversed</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=nb>enumerate</span><span class=p>(</span><span class=n>panels</span><span class=p>))):</span>
</span></span><span class=line><span class=cl>    <span class=n>area</span> <span class=o>=</span> <span class=p>(</span><span class=n>bbox</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>-</span> <span class=n>bbox</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>*</span> <span class=p>(</span><span class=n>bbox</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>-</span> <span class=n>bbox</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>area</span> <span class=o>&lt;</span> <span class=mf>0.01</span> <span class=o>*</span> <span class=n>im</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>im</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>del</span> <span class=n>panels</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span></code></pre></div><p>Here&rsquo;s a bit of code to visualize each panel.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>panel_img</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros_like</span><span class=p>(</span><span class=n>labels</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>bbox</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>panels</span><span class=p>,</span> <span class=n>start</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>panel_img</span><span class=p>[</span><span class=n>bbox</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span><span class=n>bbox</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>bbox</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span><span class=n>bbox</span><span class=p>[</span><span class=mi>3</span><span class=p>]]</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Image</span><span class=o>.</span><span class=n>fromarray</span><span class=p>(</span><span class=n>label2rgb</span><span class=p>(</span><span class=n>panel_img</span><span class=p>,</span> <span class=n>bg_label</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=mi>255</span><span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=s1>&#39;uint8&#39;</span><span class=p>))</span>
</span></span></code></pre></div><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/panels.png></figure></div><h2 id=ordering-the-panels>Ordering the panels</h2><p>The last step is to order the panels in the correct order. Indeed, we&rsquo;ve managed to segment the page into separate panels, but the panels aren&rsquo;t ordered in the order they should be read.</p><p>This is a bit trickier than I thought it would be. We could split panels by row, but a row may also contain a column, as is the case with the final row. I ended up writing a recursive function that clusters panels together if they share a vertical or horizontal coordinate. I flip between vertical and horizontal each time the function recurses. It might help to think of this as a function that is &ldquo;drilling down&rdquo; the page.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=k>def</span> <span class=nf>are_bboxes_aligned</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>axis</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>[</span><span class=mi>0</span> <span class=o>+</span> <span class=n>axis</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>[</span><span class=mi>2</span> <span class=o>+</span> <span class=n>axis</span><span class=p>]</span> <span class=ow>and</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=p>[</span><span class=mi>0</span> <span class=o>+</span> <span class=n>axis</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>a</span><span class=p>[</span><span class=mi>2</span> <span class=o>+</span> <span class=n>axis</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>cluster_bboxes</span><span class=p>(</span><span class=n>bboxes</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>clusters</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Regroup bboxes which overlap along the current axis.</span>
</span></span><span class=line><span class=cl>    <span class=c1># For instance, two panels on the same row overlap</span>
</span></span><span class=line><span class=cl>    <span class=c1># along their verticial coordinate.</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>bbox</span> <span class=ow>in</span> <span class=n>bboxes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>cluster</span> <span class=ow>in</span> <span class=n>clusters</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>any</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>are_bboxes_aligned</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>bbox</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>b</span> <span class=ow>in</span> <span class=n>cluster</span>
</span></span><span class=line><span class=cl>            <span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>cluster</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>bbox</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>clusters</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>bbox</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># We want rows to be ordered from top to bottom, and</span>
</span></span><span class=line><span class=cl>    <span class=c1># columns to be ordered from left to right.</span>
</span></span><span class=line><span class=cl>    <span class=n>clusters</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>c</span><span class=p>:</span> <span class=n>c</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span> <span class=o>+</span> <span class=n>axis</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># For each row, we want to cluster the panels of that</span>
</span></span><span class=line><span class=cl>    <span class=c1># row into columns, etc. etc.</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>cluster</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>clusters</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>cluster</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>clusters</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>cluster_bboxes</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>bboxes</span><span class=o>=</span><span class=n>cluster</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>axis</span><span class=o>=</span><span class=mi>1</span> <span class=k>if</span> <span class=n>axis</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>clusters</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>clusters</span> <span class=o>=</span> <span class=n>cluster_bboxes</span><span class=p>(</span><span class=n>panels</span><span class=p>)</span>
</span></span></code></pre></div><p>The <code>clusters</code> variable is now an arbitrarily nested list of bounding boxes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>clusters</span>
</span></span><span class=line><span class=cl><span class=p>[[[(</span><span class=mi>122</span><span class=p>,</span> <span class=mi>116</span><span class=p>,</span> <span class=mi>922</span><span class=p>,</span> <span class=mi>755</span><span class=p>)],</span> <span class=p>[(</span><span class=mi>122</span><span class=p>,</span> <span class=mi>765</span><span class=p>,</span> <span class=mi>922</span><span class=p>,</span> <span class=mi>1886</span><span class=p>)]],</span>
</span></span><span class=line><span class=cl> <span class=p>[[(</span><span class=mi>933</span><span class=p>,</span> <span class=mi>115</span><span class=p>,</span> <span class=mi>1728</span><span class=p>,</span> <span class=mi>543</span><span class=p>)],</span> <span class=p>[(</span><span class=mi>934</span><span class=p>,</span> <span class=mi>551</span><span class=p>,</span> <span class=mi>1727</span><span class=p>,</span> <span class=mi>988</span><span class=p>)],</span> <span class=p>[(</span><span class=mi>931</span><span class=p>,</span> <span class=mi>995</span><span class=p>,</span> <span class=mi>1729</span><span class=p>,</span> <span class=mi>1882</span><span class=p>)]],</span>
</span></span><span class=line><span class=cl> <span class=p>[[[(</span><span class=mi>1740</span><span class=p>,</span> <span class=mi>115</span><span class=p>,</span> <span class=mi>2038</span><span class=p>,</span> <span class=mi>1220</span><span class=p>)],</span> <span class=p>[(</span><span class=mi>2049</span><span class=p>,</span> <span class=mi>115</span><span class=p>,</span> <span class=mi>2538</span><span class=p>,</span> <span class=mi>1220</span><span class=p>)]],</span>
</span></span><span class=line><span class=cl>  <span class=p>[(</span><span class=mi>1740</span><span class=p>,</span> <span class=mi>1232</span><span class=p>,</span> <span class=mi>2539</span><span class=p>,</span> <span class=mi>1885</span><span class=p>)]]]</span>
</span></span></code></pre></div><p>I wrote some code to flatten it, so that we can loop over the bounding boxes in the order they&rsquo;re supposed to be looked at by the reader. Then for the purpose of debugging, I wrote a digit on each panel to verify the resulting order.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>from</span> <span class=nn>PIL</span> <span class=kn>import</span> <span class=n>ImageFont</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>PIL</span> <span class=kn>import</span> <span class=n>ImageDraw</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>img</span> <span class=o>=</span> <span class=n>Image</span><span class=o>.</span><span class=n>fromarray</span><span class=p>(</span><span class=n>im</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>draw</span> <span class=o>=</span> <span class=n>ImageDraw</span><span class=o>.</span><span class=n>Draw</span><span class=p>(</span><span class=n>img</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>font</span> <span class=o>=</span> <span class=n>ImageFont</span><span class=o>.</span><span class=n>truetype</span><span class=p>(</span><span class=s1>&#39;OpenSans-Bold.ttf&#39;</span><span class=p>,</span> <span class=mi>160</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>flatten</span><span class=p>(</span><span class=n>l</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>el</span> <span class=ow>in</span> <span class=n>l</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>el</span><span class=p>,</span> <span class=nb>list</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>yield from</span> <span class=n>flatten</span><span class=p>(</span><span class=n>el</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>yield</span> <span class=n>el</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>bbox</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>flatten</span><span class=p>(</span><span class=n>clusters</span><span class=p>),</span> <span class=n>start</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>w</span><span class=p>,</span> <span class=n>h</span> <span class=o>=</span> <span class=n>draw</span><span class=o>.</span><span class=n>textsize</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>i</span><span class=p>),</span> <span class=n>font</span><span class=o>=</span><span class=n>font</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>bbox</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>bbox</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>-</span> <span class=n>w</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=p>(</span><span class=n>bbox</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>bbox</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>-</span> <span class=n>h</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>draw</span><span class=o>.</span><span class=n>text</span><span class=p>((</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>),</span> <span class=nb>str</span><span class=p>(</span><span class=n>i</span><span class=p>),</span> <span class=p>(</span><span class=mi>255</span><span class=p>,</span> <span class=mi>215</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span> <span class=n>font</span><span class=o>=</span><span class=n>font</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>img</span>
</span></span></code></pre></div><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/order.png></figure></div><p>There we go, that&rsquo;s correct. If we wanted to, we could now save each panel as a separate image, as so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>makedirs</span><span class=p>(</span><span class=s1>&#39;panels&#39;</span><span class=p>,</span> <span class=n>exists_ok</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>bbox</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>flatten</span><span class=p>(</span><span class=n>clusters</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>    <span class=n>panel</span> <span class=o>=</span> <span class=n>im</span><span class=p>[</span><span class=n>bbox</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span><span class=n>bbox</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>bbox</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span><span class=n>bbox</span><span class=p>[</span><span class=mi>3</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>    <span class=n>Image</span><span class=o>.</span><span class=n>fromarray</span><span class=p>(</span><span class=n>panel</span><span class=p>)</span><span class=o>.</span><span class=n>save</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;panels/</span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s1>.png&#39;</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=edge-cases>Edge cases</h2><p>I determined which steps to perform by working with a single example. Obviously, there is no guarantee this process will work for any given comic strip page. Here is a harder example where the process is successful:</p><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/order_nested.png></figure></div><p>This example is a tad harder because of the nesting of the panels. Indeed, the second and third panel are part of a row, which is itself part of a column, which is part of a row. But the recursive clustering function handles this rather well.</p><p>One case I haven&rsquo;t handled is when speech bubbles are spread across multiple panels. This causes the panel bounding box to overlap, which actually causes an infinite recursion. For instance, see the following image, and the bounding boxes obtained before the clustering step.</p><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/RCO013_1468214847.jpg></figure></div><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/overlapping_panels.png><figcaption>You can vaguely see the purple bounding overlapping with the orange and light blue panels.</figcaption></figure></div><p>Another thing I didn&rsquo;t take care of is the handling of non-square panels. For example, in the following image, the clustering process regroups the panels on the fourth row because they are aligned both horizontally and vertically, due to the fact the panels are not rectangular.</p><div align=center><figure style=width:90%><img src=/img/blog/comic-book-panel-segmentation/non_rectangular_panels.png></figure></div><p>I&rsquo;m sure there are other edge cases out there. However, I&rsquo;m quite confident it&rsquo;s possible to build a robust pipeline that handles almost all cases. I&rsquo;ll leave that as an exercise for the reader ãƒ„</p><h2 id=further-reading>Further reading</h2><p>I initially set out to work on this without checking what had already been done. But afterwards I found a few related things:</p><ul><li><a href=https://www.mdpi.com/2313-433X/4/7/89/htm>Digital Comics Image Indexing Based on Deep Learning</a></li><li><a href=https://tel.archives-ouvertes.fr/tel-01221308/document>Segmentation and indexation of complex objects in comic book images</a></li><li><a href=https://venturebeat.com/2019/02/22/ai-extracts-speech-bubbles-from-comic-strips/>AI extracts speech bubbles from comic strips</a></li><li><a href=https://www.researchgate.net/publication/337232656_What_do_We_Expect_from_Comic_Panel_Extraction>What do We Expect from Comic Panel Extraction?</a></li><li><a href=https://visal.cs.cityu.edu.hk/static/pubs/conf/mm14-panels.pdf>A Robust Panel Extraction Method for Manga</a></li><li><a href=https://www.researchgate.net/publication/258423562_Segmentation-Free_Detection_of_Comic_Panels>Segmentation-Free Detection of Comic Panels</a></li></ul><p>I&rsquo;m actually pleasantly impressed by the amount of work that seems to have been poured into such an apparently trivial topic. Humans never cease to be surprising!</p></div><script type=text/javascript>var s=document.createElement("script");s.setAttribute("src","https://utteranc.es/client.js"),s.setAttribute("repo","MaxHalford/maxhalford.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",null),s.setAttribute("theme","github-light"),document.body.appendChild(s)</script><div style=display:flex;flex-direction:row;justify-content:center;align-items:center;gap:20px;margin-bottom:30px><div class=do-the-thing><div class=elevator><svg class="sweet-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" enable-background="new 0 0 100 100" height="100" width="100"><path d="M70 47.5H30c-1.4.0-2.5 1.1-2.5 2.5v40c0 1.4 1.1 2.5 2.5 2.5h40c1.4.0 2.5-1.1 2.5-2.5V50C72.5 48.6 71.4 47.5 70 47.5zm-22.5 40h-5v-25h5v25zm10 0h-5v-25h5v25zm10 0h-5V60c0-1.4-1.1-2.5-2.5-2.5H40c-1.4.0-2.5 1.1-2.5 2.5v27.5h-5v-35h35v35z"/><path d="M50 42.5c1.4.0 2.5-1.1 2.5-2.5V16l5.7 5.7c.5.5 1.1.7 1.8.7s1.3-.2 1.8-.7c1-1 1-2.6.0-3.5l-10-10c-1-1-2.6-1-3.5.0l-10 10c-1 1-1 2.6.0 3.5 1 1 2.6 1 3.5.0l5.7-5.7v24c0 1.4 1.1 2.5 2.5 2.5z"/></svg>
Back to the top</div></div><iframe src=https://github.com/sponsors/MaxHalford/button title="Sponsor MaxHalford" height=32 width=114 style=border:0;border-radius:6px></iframe></div><script src=https://cdnjs.cloudflare.com/ajax/libs/elevator.js/1.0.1/elevator.min.js></script><script>var elementButton=document.querySelector(".elevator"),elevator=new Elevator({element:elementButton,mainAudio:"/music/elevator.mp3",endAudio:"/music/ding.mp3"})</script><style>.down-arrow{font-size:120px;margin-top:90px;margin-bottom:90px;text-shadow:0 -20px #0c1f31,0 0 #c33329;color:transparent;-webkit-transform:scaleY(.8);-moz-transform:scaleY(.8);transform:scaleY(.8)}.elevator{text-align:center;cursor:pointer;width:140px;margin:auto}.elevator:hover{opacity:.7}.elevator svg{width:40px;height:40px;display:block;margin:auto;margin-bottom:5px}</style><div class=related-content><h3 style=margin-top:10px!important;margin-bottom:10px!important>Related posts</h3><ul style=margin-top:0><li><a href=/blog/halftoning-2/>Halftoning with Go - Part 2</a></li><li><a href=/blog/halftoning-1/>Halftoning with Go - Part 1</a></li></ul></div></div></div></article></body></html>