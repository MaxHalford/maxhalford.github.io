<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on Max Halford</title><link>https://maxhalford.github.io/tags/python/</link><description>Recent content in python on Max Halford</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>maxhalford25@gmail.com (Max Halford)</managingEditor><webMaster>maxhalford25@gmail.com (Max Halford)</webMaster><lastBuildDate>Wed, 15 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maxhalford.github.io/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Using SymPy in Python doctests</title><link>https://maxhalford.github.io/blog/sympy-doctests/</link><pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate><author>maxhalford25@gmail.com (Max Halford)</author><guid>https://maxhalford.github.io/blog/sympy-doctests/</guid><description>A program which compiles and runs without errors isn&amp;rsquo;t necessarily correct. I find this to be especially true for statistical software, both as a developer and as a user. Small but nasty bugs creep up on me every week. I keep sane in the membrane by writing many unit tests üêõüî®
I make heavy use of doctests. These are unit tests which you write as Python docstrings. They&amp;rsquo;re really handy because they kill two birds with one stone: the unit tests you write for a function also act as documentation.</description></item><item><title>Weighted sampling without replacement in pure Python</title><link>https://maxhalford.github.io/blog/weighted-sampling-without-replacement/</link><pubDate>Fri, 24 Dec 2021 00:00:00 +0000</pubDate><author>maxhalford25@gmail.com (Max Halford)</author><guid>https://maxhalford.github.io/blog/weighted-sampling-without-replacement/</guid><description>I&amp;rsquo;m working on a problem where I need to sample k items from a list without replacement. The sampling has to be weighted. In Python, numpy has random.choice method which allows doing this:
import numpy as np n = 10 k = 3 np.random.seed(42) population = np.arange(n) weights = np.random.dirichlet(np.ones_like(population)) np.random.choice(population, size=k, replace=False, p=weights) array([0, 9, 8]) I&amp;rsquo;m always wary of using numpy without thinking because I know it incurs some overhead.</description></item></channel></rss>