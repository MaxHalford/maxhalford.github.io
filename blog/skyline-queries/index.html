<!doctype html><html lang=en><head><script defer src=https://unpkg.com/@tinybirdco/flock.js data-host=https://api.tinybird.co data-token=p.eyJ1IjogImMwMjJhMjg1LWJmY2YtNDc0OC1hYzczLTJhMDQ1Njk3NTI0YyIsICJpZCI6ICIzNjc3NjQ3Ny04MTE2LTRmYWQtYjcwMy1iZmM3YjMwZGJjMjMifQ.A0vHm-VWbXG6uBFZiwuspN_AyfSYNrdZE3IgwgWSt4g></script><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Max Halford"><meta property="og:url" content="https://maxhalford.github.io/blog/skyline-queries/"><link rel=canonical href=https://maxhalford.github.io/blog/skyline-queries/><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦”</text></svg>"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/maxhalford.github.io\/"},"articleSection":"blog","name":"Skyline queries in Python","headline":"Skyline queries in Python","description":"Imagine that you\u0026rsquo;re looking to buy a home. If you have an analytical mind then you might want to tackle this with a quantitative. Let\u0026rsquo;s suppose that you have a list of potential homes, and each home has some attributes that can help you compare them. As an example, we\u0026rsquo;ll consider three attributes:\nThe price of the house, which you want to minimize The size of the house, which you want to maximize The city where the house if located, which you don\u0026rsquo;t really care about Some houses will be objectively better than others because they will be cheaper and bigger.","inLanguage":"en-US","author":"Max Halford","creator":"Max Halford","publisher":"Max Halford","accountablePerson":"Max Halford","copyrightHolder":"Max Halford","copyrightYear":"2019","datePublished":"2019-05-21 00:00:00 \u002b0000 UTC","dateModified":"2019-05-21 00:00:00 \u002b0000 UTC","url":"https:\/\/maxhalford.github.io\/blog\/skyline-queries\/","keywords":["data-eng"]}</script><title>Skyline queries in Python â€¢ Max Halford</title><meta property="og:title" content="Skyline queries in Python â€¢ Max Halford"><meta property="og:type" content="article"><meta name=description content="Imagine that you&rsquo;re looking to buy a home. If you have an analytical mind then you might want to tackle this with a quantitative. Let&rsquo;s suppose that you have a list of potential homes, and each home has some attributes that can help you compare them. As an example, we&rsquo;ll consider three attributes:
The price of the house, which you want to minimize The size of the house, which you want to maximize The city where the house if located, which you don&rsquo;t really care about Some houses will be objectively better than others because they will be cheaper and bigger."><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/highlight/github.css><link rel=stylesheet href=/css/index.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Permanent+Marker&display=swap" rel=stylesheet><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><article class=post id=article><div class="row center-xs" style=text-align:left><div class="col-xs-12 col-sm-10 col-md-7 col-lg-5"><div class=header><header class=header-parts><div class="signatures site-title"><a href=/>Max Halford ðŸ¦”</a></div><div class=header-links><a class=header-link href=/>Blog</a>
<a class=header-link href=/links/>Links</a>
<a class=header-link href=/bio/>Bio</a></div></header></div><header class=post-header><h1 class=post-title>Skyline queries in Python</h1><div class="row post-desc"><div class="col-xs-12 post-desc-items"><time class=post-date datetime="2019-05-21 00:00:00 UTC">2019-05-21</time>
<span class=posts-line-tag>data-eng</span></div></div></header><div class="post-content markdown-body"><p>Imagine that you&rsquo;re looking to buy a home. If you have an analytical mind then you might want to tackle this with a quantitative. Let&rsquo;s suppose that you have a list of potential homes, and each home has some attributes that can help you compare them. As an example, we&rsquo;ll consider three attributes:</p><ul><li>The <code>price</code> of the house, which you want to minimize</li><li>The <code>size</code> of the house, which you want to maximize</li><li>The <code>city</code> where the house if located, which you don&rsquo;t really care about</li></ul><p>Some houses will be objectively better than others because they will be cheaper and bigger. However, for some pairs of houses the comparison will not be as clear. It might be that house A is more expensive than house B but is also larger. In data analysis this set of best houses which are incomparable with each other is called a <a href=https://www.wikiwand.com/en/Skyline_operator>skyline</a>. As they say, a picture is worth a thousand words, so let&rsquo;s draw one.</p><p>We&rsquo;ll simulate some houses using a very simple random process. Each house will be located in a random city. Then, the size of the house in square meters will be sampled from a normal distribution with mean 200 and standard deviation 50. Finally, the price of the house will be obtained by multiplying the size of the house by a price per square meter sampled from a given uniform distribution. I chose as cities Bordeaux, Lyon, and Toulouse. I got the prices per square meter from <a href=https://www.meilleursagents.com/>meilleursagents.com</a>. In any case, none of the details really matter. The following piece of code will generate <code>n_houses</code> houses using the process I just described.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pandas</span> <span class=k>as</span> <span class=nn>pd</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>city_prices</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;Bordeaux&#39;</span><span class=p>:</span> <span class=mi>4045</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;Lyon&#39;</span><span class=p>:</span> <span class=mi>4547</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;Toulouse&#39;</span><span class=p>:</span> <span class=mi>3278</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_houses</span><span class=p>(</span><span class=n>n_houses</span><span class=p>,</span> <span class=n>city_prices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cities</span> <span class=o>=</span> <span class=p>[</span><span class=n>city</span> <span class=k>for</span> <span class=n>city</span> <span class=ow>in</span> <span class=n>city_prices</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n_houses</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sizes</span> <span class=o>=</span> <span class=p>[</span><span class=nb>round</span><span class=p>(</span><span class=n>random</span><span class=o>.</span><span class=n>gauss</span><span class=p>(</span><span class=mi>200</span><span class=p>,</span> <span class=mi>50</span><span class=p>))</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>cities</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>prices</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=nb>round</span><span class=p>(</span><span class=n>random</span><span class=o>.</span><span class=n>uniform</span><span class=p>(</span><span class=mf>0.8</span><span class=p>,</span> <span class=mf>1.2</span><span class=p>)</span> <span class=o>*</span> <span class=n>city_prices</span><span class=p>[</span><span class=n>city</span><span class=p>]</span> <span class=o>*</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>city</span><span class=p>,</span> <span class=n>size</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>cities</span><span class=p>,</span> <span class=n>sizes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>({</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;city&#39;</span><span class=p>:</span> <span class=n>cities</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;size&#39;</span><span class=p>:</span> <span class=n>sizes</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;price&#39;</span><span class=p>:</span> <span class=n>prices</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span></code></pre></div><p>To start let&rsquo;s generate 100 houses and display the first 5.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>houses</span> <span class=o>=</span> <span class=n>make_houses</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=n>city_prices</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>houses</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span></code></pre></div><table><thead><tr><th><strong>city</strong></th><th><strong>size</strong></th><th><strong>price</strong></th></tr></thead><tbody><tr><td>Lyon</td><td>170</td><td>733290</td></tr><tr><td>Lyon</td><td>127</td><td>557921</td></tr><tr><td>Bordeaux</td><td>227</td><td>857932</td></tr><tr><td>Lyon</td><td>168</td><td>621432</td></tr><tr><td>Toulouse</td><td>170</td><td>519786</td></tr></tbody></table><p>Now let&rsquo;s display all of the houses using a simple scatter plot.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ax</span> <span class=o>=</span> <span class=n>houses</span><span class=o>.</span><span class=n>plot</span><span class=o>.</span><span class=n>scatter</span><span class=p>(</span><span class=n>x</span><span class=o>=</span><span class=s1>&#39;size&#39;</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=s1>&#39;price&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;100 simulated houses&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p><img src=/img/blog/skyline-queries/houses.svg alt=houses></p><p>The points that are to the bottom right are part of the skyline. Indeed they are either better or not comparable to the rest of the points. In other words, for any point in the skyline, it is impossible to find a point which is at least as good in every regard. In optimisation this is called the <a href=https://www.wikiwand.com/en/Pareto_efficiency#/Pareto_frontier>Pareto frontier</a> (the link has some nice visuals).</p><p>I was surprised to find that there isn&rsquo;t any canonical way to do this in <code>pandas</code>, and that not many people at all discuss how to find a skyline using Python. On the other hand skylines are really useful for specific tasks, such as ranking items online. For example if you&rsquo;re looking for a hotel you might to find one that is cheap, big, and close to the beach. Instead of looking at each hotel you could first compute the skyline and check those instead. Of course there will be always some attributes that are impossible to rank because they depend on a person&rsquo;s taste, but you get the idea. Some things are just objectively better.</p><p>I decided to first code a very naive implementation so that I could use it as a baseline. The idea is simply to search for the skyline using brute force. Each row is compared with the rest of the rows and discarded if it is dominated by at least one of them. To make things as clear as possible I first wrote a <code>a_dominated_b</code> function to check if a row called <code>a</code> dominates another row called <code>b</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>a_dominates_b</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>to_min</span><span class=p>,</span> <span class=n>to_max</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>n_better</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>f</span> <span class=ow>in</span> <span class=n>to_min</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>a</span><span class=p>[</span><span class=n>f</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>[</span><span class=n>f</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=n>n_better</span> <span class=o>+=</span> <span class=n>a</span><span class=p>[</span><span class=n>f</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>[</span><span class=n>f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>f</span> <span class=ow>in</span> <span class=n>to_max</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>a</span><span class=p>[</span><span class=n>f</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>[</span><span class=n>f</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=n>n_better</span> <span class=o>+=</span> <span class=n>a</span><span class=p>[</span><span class=n>f</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>[</span><span class=n>f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n_better</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>False</span>
</span></span></code></pre></div><p>The implementation is quite simple. The <code>to_min</code> parameter lists the attributes that have to be minimized while <code>to_max</code> lists those that have to be, you guessed it, maximized. The only quirk happens when <code>a</code> and <code>b</code> are equal. In this case the expected &ndash; and intended &ndash; behavior is that <code>a_dominates_b</code> returns <code>False</code>.</p><p>For the sake of the example here&rsquo;s a sample usage where <code>a</code> dominates <code>b</code> because it is cheaper.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;price&#39;</span><span class=p>:</span> <span class=mi>100_000</span><span class=p>,</span> <span class=s1>&#39;size&#39;</span><span class=p>:</span> <span class=mi>230</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>b</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;price&#39;</span><span class=p>:</span> <span class=mi>120_000</span><span class=p>,</span> <span class=s1>&#39;size&#39;</span><span class=p>:</span> <span class=mi>200</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>a_dominates_b</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>to_min</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;price&#39;</span><span class=p>],</span> <span class=n>b</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;size&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=kc>True</span>
</span></span></code></pre></div><p>Now we simply have to implement the nested <code>for</code> loops that searches for the skyline.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_skyline_brute_force</span><span class=p>(</span><span class=n>df</span><span class=p>,</span> <span class=n>to_min</span><span class=p>,</span> <span class=n>to_max</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>rows</span> <span class=o>=</span> <span class=n>df</span><span class=o>.</span><span class=n>to_dict</span><span class=p>(</span><span class=n>orient</span><span class=o>=</span><span class=s1>&#39;index&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>skyline</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>rows</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>dominated</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>rows</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=n>j</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>a_dominates_b</span><span class=p>(</span><span class=n>rows</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>rows</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>to_min</span><span class=p>,</span> <span class=n>to_max</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>dominated</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>dominated</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>skyline</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>pd</span><span class=o>.</span><span class=n>Series</span><span class=p>(</span><span class=n>df</span><span class=o>.</span><span class=n>index</span><span class=o>.</span><span class=n>isin</span><span class=p>(</span><span class=n>skyline</span><span class=p>),</span> <span class=n>index</span><span class=o>=</span><span class=n>df</span><span class=o>.</span><span class=n>index</span><span class=p>)</span>
</span></span></code></pre></div><p>In my implementation I return a <code>pandas.Series</code> which contains <code>bool</code>s that indicate whether or not a row is part of the skyline. Let&rsquo;s use this function to search for the skyline of the houses we generated earlier on, and then display them.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>skyline</span> <span class=o>=</span> <span class=n>find_skyline_brute_force</span><span class=p>(</span><span class=n>houses</span><span class=p>,</span> <span class=n>to_min</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;price&#39;</span><span class=p>],</span> <span class=n>to_max</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;size&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>colors</span> <span class=o>=</span> <span class=n>skyline</span><span class=o>.</span><span class=n>map</span><span class=p>({</span><span class=kc>True</span><span class=p>:</span> <span class=s1>&#39;C1&#39;</span><span class=p>,</span> <span class=kc>False</span><span class=p>:</span> <span class=s1>&#39;C0&#39;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=n>ax</span> <span class=o>=</span> <span class=n>houses</span><span class=o>.</span><span class=n>plot</span><span class=o>.</span><span class=n>scatter</span><span class=p>(</span><span class=n>x</span><span class=o>=</span><span class=s1>&#39;size&#39;</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=s1>&#39;price&#39;</span><span class=p>,</span> <span class=n>c</span><span class=o>=</span><span class=n>colors</span><span class=p>,</span> <span class=n>alpha</span><span class=o>=</span><span class=mf>0.8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;Houses skyline&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p><img src=/img/blog/skyline-queries/skyline.svg alt=skyline></p><p>I&rsquo;m too lazy to write unit tests, but this seems correct, right? As expected, the running time of this algorithm grows quadratically with the size of the dataset, and basically isn&rsquo;t viable above 10,000 rows. It turns out there are many other algorithms which are much more efficient. I picked a simple one which uses a <a href="http://lmgtfy.com/?q=block+nested+loop+skyline">block nested loop (BNL)</a>. It seems to perform well for common cases, at least according to the few papers I skimmed through. The idea is to maintain a skyline and compare each incoming row with each element of the skyline. One of three cases can occur:</p><ol><li>The point is dominated by one of the elements in the skyline.</li><li>The point dominates one or more points in the skyline.</li><li>The point is neither better nor worse than all of the points in the skyline.</li></ol><p>In case 1 the point is simply ignored. In cases 2 and 3 the point will be inserted in the skyline. In case 2 the points in the skyline that are dominated are also deleted from the skyline. All in all the algorithm is quite simple but it took me some time to convince myself. I scratched my head a bit to get this to keep rows that are equal in all regards. Anyway, here is the code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>count_diffs</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>to_min</span><span class=p>,</span> <span class=n>to_max</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n_better</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>n_worse</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>f</span> <span class=ow>in</span> <span class=n>to_min</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>n_better</span> <span class=o>+=</span> <span class=n>a</span><span class=p>[</span><span class=n>f</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>[</span><span class=n>f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>n_worse</span> <span class=o>+=</span> <span class=n>a</span><span class=p>[</span><span class=n>f</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>[</span><span class=n>f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>f</span> <span class=ow>in</span> <span class=n>to_max</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>n_better</span> <span class=o>+=</span> <span class=n>a</span><span class=p>[</span><span class=n>f</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>[</span><span class=n>f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>n_worse</span> <span class=o>+=</span> <span class=n>a</span><span class=p>[</span><span class=n>f</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>[</span><span class=n>f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>n_better</span><span class=p>,</span> <span class=n>n_worse</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_skyline_bnl</span><span class=p>(</span><span class=n>df</span><span class=p>,</span> <span class=n>to_min</span><span class=p>,</span> <span class=n>to_max</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Finds the skyline using a block-nested loop.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>rows</span> <span class=o>=</span> <span class=n>df</span><span class=o>.</span><span class=n>to_dict</span><span class=p>(</span><span class=n>orient</span><span class=o>=</span><span class=s1>&#39;index&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Use the first row to initialize the skyline</span>
</span></span><span class=line><span class=cl>    <span class=n>skyline</span> <span class=o>=</span> <span class=p>{</span><span class=n>df</span><span class=o>.</span><span class=n>index</span><span class=p>[</span><span class=mi>0</span><span class=p>]}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Loop through the rest of the rows</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>df</span><span class=o>.</span><span class=n>index</span><span class=p>[</span><span class=mi>1</span><span class=p>:]:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>to_drop</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>is_dominated</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>skyline</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>n_better</span><span class=p>,</span> <span class=n>n_worse</span> <span class=o>=</span> <span class=n>count_diffs</span><span class=p>(</span><span class=n>rows</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>rows</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>to_min</span><span class=p>,</span> <span class=n>to_max</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># Case 1</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>n_worse</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>n_better</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>is_dominated</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># Case 3</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>n_better</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>n_worse</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>to_drop</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>is_dominated</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>skyline</span> <span class=o>=</span> <span class=n>skyline</span><span class=o>.</span><span class=n>difference</span><span class=p>(</span><span class=n>to_drop</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>skyline</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>pd</span><span class=o>.</span><span class=n>Series</span><span class=p>(</span><span class=n>df</span><span class=o>.</span><span class=n>index</span><span class=o>.</span><span class=n>isin</span><span class=p>(</span><span class=n>skyline</span><span class=p>),</span> <span class=n>index</span><span class=o>=</span><span class=n>df</span><span class=o>.</span><span class=n>index</span><span class=p>)</span>
</span></span></code></pre></div><p>The <code>count_diffs</code> method returns two counters which indicated one many attributes are better and how many are worse given two rows. The counters can then be used to map to one of the three cases listed above. Case 1 corresponds to <code>n_worse > 0 and n_better == 0</code> while <code>n_better > 0 and n_worse == 0</code> refers to case 2. Note that the case where <code>n_worse</code> and <code>n_better</code> are both equal to 0 means that <code>a</code> and <code>b</code> are identical. I have to say I am not 100% happy with the implementation, indeed my gut tells me there is a simpler way. But at least it does the trick.</p><p>A nice thing we can now do is compare <code>find_skyline_bnl</code> with <code>find_skyline_brute_force</code> to check that they output the same results. We can do so using the <code>assert_series_equal</code> function from <code>pandas</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>30</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>houses</span> <span class=o>=</span> <span class=n>make_houses</span><span class=p>(</span><span class=n>n_houses</span><span class=o>=</span><span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>120</span><span class=p>,</span> <span class=mi>140</span><span class=p>),</span> <span class=n>city_prices</span><span class=o>=</span><span class=n>city_prices</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pd</span><span class=o>.</span><span class=n>testing</span><span class=o>.</span><span class=n>assert_series_equal</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>find_skyline_brute_force</span><span class=p>(</span><span class=n>df</span><span class=o>=</span><span class=n>houses</span><span class=p>,</span> <span class=n>to_min</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;price&#39;</span><span class=p>],</span> <span class=n>to_max</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;size&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>        <span class=n>find_skyline_bnl</span><span class=p>(</span><span class=n>df</span><span class=o>=</span><span class=n>houses</span><span class=p>,</span> <span class=n>to_min</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;price&#39;</span><span class=p>],</span> <span class=n>to_max</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;size&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span></code></pre></div><p>Next we can compare the running time of both algorithms on a dataset of, say, 5000 houses.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>houses</span> <span class=o>=</span> <span class=n>make_houses</span><span class=p>(</span><span class=n>n_houses</span><span class=o>=</span><span class=mi>5_000</span><span class=p>,</span> <span class=n>city_prices</span><span class=o>=</span><span class=n>city_prices</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>tic</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>skyline</span> <span class=o>=</span> <span class=n>find_skyline_brute_force</span><span class=p>(</span><span class=n>df</span><span class=o>=</span><span class=n>houses</span><span class=p>,</span> <span class=n>to_min</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;price&#39;</span><span class=p>],</span> <span class=n>to_max</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;size&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;Brute-force took </span><span class=si>{</span><span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>tic</span><span class=si>:</span><span class=s1>.3f</span><span class=si>}</span><span class=s1> seconds&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>tic</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>skyline</span> <span class=o>=</span> <span class=n>find_skyline_bnl</span><span class=p>(</span><span class=n>df</span><span class=o>=</span><span class=n>houses</span><span class=p>,</span> <span class=n>to_min</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;price&#39;</span><span class=p>],</span> <span class=n>to_max</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;size&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;Block nested loop took </span><span class=si>{</span><span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>tic</span><span class=si>:</span><span class=s1>.3f</span><span class=si>}</span><span class=s1> seconds&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>This outputs the following:</p><pre tabindex=0><code>Brute-force took 10.658 seconds
Block nested loop took 0.320 seconds
</code></pre><p>In this case the block nested loop is over 30 times faster than the brute-force approach, which is great. Finally let&rsquo;s look at how the execution time of the block nested loop method evolves with the number of rows. I simply recorded the execution time for sizes between 10,000 and 100,000 with a step of 10,000. I repeated the results 10 times in order to compute an average and a standard deviation which can be displayed using <a href=https://seaborn.pydata.org>seaborn</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>seaborn</span> <span class=k>as</span> <span class=nn>sns</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>measure_time</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>houses</span> <span class=o>=</span> <span class=n>make_houses</span><span class=p>(</span><span class=n>n_houses</span><span class=o>=</span><span class=n>n</span><span class=p>,</span> <span class=n>city_prices</span><span class=o>=</span><span class=n>city_prices</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tic</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>skyline</span> <span class=o>=</span> <span class=n>find_skyline_bnl</span><span class=p>(</span><span class=n>df</span><span class=o>=</span><span class=n>houses</span><span class=p>,</span> <span class=n>to_min</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;price&#39;</span><span class=p>],</span> <span class=n>to_max</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;size&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>tic</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>durations</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>([</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s1>&#39;size&#39;</span><span class=p>:</span> <span class=n>n</span><span class=p>,</span> <span class=s1>&#39;duration&#39;</span><span class=p>:</span> <span class=n>measure_time</span><span class=p>(</span><span class=n>n</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>     <span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>10000</span><span class=p>,</span> <span class=mi>110_000</span><span class=p>,</span> <span class=mi>10000</span><span class=p>)</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ax</span> <span class=o>=</span> <span class=n>sns</span><span class=o>.</span><span class=n>lineplot</span><span class=p>(</span><span class=n>x</span><span class=o>=</span><span class=s1>&#39;size&#39;</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=s1>&#39;duration&#39;</span><span class=p>,</span> <span class=n>data</span><span class=o>=</span><span class=n>durations</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=o>.</span><span class=n>grid</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;Running time in seconds of the BNL algorithm&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p><img src=/img/blog/skyline-queries/durations.svg alt=durations></p><p>I didn&rsquo;t take the time to code any other algorithm but I&rsquo;m rather satisfied with this for the moment. I&rsquo;m going to open an issue on <code>pandas</code> and see if there is any interest to pursue this further. One property of the block nested loop algorithm that might have gone unnoticed is that it works for streaming scenarios, and I will thus be adding an implementation to <a href=https://github.com/creme-ml/creme>creme</a> in the upcoming days.</p><p>I hope you enjoyed the read. Feel free to get in touch if anything bugs you or if you know any better algorithm.</p></div><script type=text/javascript>var s=document.createElement("script");s.setAttribute("src","https://utteranc.es/client.js"),s.setAttribute("repo","MaxHalford/maxhalford.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",null),s.setAttribute("theme","github-light"),document.body.appendChild(s)</script><div style=display:flex;flex-direction:row;justify-content:center;align-items:center;gap:20px;margin-bottom:30px><div class=do-the-thing><div class=elevator><svg class="sweet-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" enable-background="new 0 0 100 100" height="100" width="100"><path d="M70 47.5H30c-1.4.0-2.5 1.1-2.5 2.5v40c0 1.4 1.1 2.5 2.5 2.5h40c1.4.0 2.5-1.1 2.5-2.5V50C72.5 48.6 71.4 47.5 70 47.5zm-22.5 40h-5v-25h5v25zm10 0h-5v-25h5v25zm10 0h-5V60c0-1.4-1.1-2.5-2.5-2.5H40c-1.4.0-2.5 1.1-2.5 2.5v27.5h-5v-35h35v35z"/><path d="M50 42.5c1.4.0 2.5-1.1 2.5-2.5V16l5.7 5.7c.5.5 1.1.7 1.8.7s1.3-.2 1.8-.7c1-1 1-2.6.0-3.5l-10-10c-1-1-2.6-1-3.5.0l-10 10c-1 1-1 2.6.0 3.5 1 1 2.6 1 3.5.0l5.7-5.7v24c0 1.4 1.1 2.5 2.5 2.5z"/></svg>Back to the top</div></div><iframe src=https://github.com/sponsors/MaxHalford/button title="Sponsor MaxHalford" height=32 width=114 style=border:0;border-radius:6px></iframe></div><script src=https://cdnjs.cloudflare.com/ajax/libs/elevator.js/1.0.1/elevator.min.js></script>
<script>var elementButton=document.querySelector(".elevator"),elevator=new Elevator({element:elementButton,mainAudio:"/music/elevator.mp3",endAudio:"/music/ding.mp3"})</script><style>.down-arrow{font-size:120px;margin-top:90px;margin-bottom:90px;text-shadow:0 -20px #0c1f31,0 0 #c33329;color:transparent;-webkit-transform:scaleY(.8);-moz-transform:scaleY(.8);transform:scaleY(.8)}.elevator{text-align:center;cursor:pointer;width:140px;margin:auto}.elevator:hover{opacity:.7}.elevator svg{width:40px;height:40px;display:block;margin:auto;margin-bottom:5px}</style></div></div></article><script></script></body></html>