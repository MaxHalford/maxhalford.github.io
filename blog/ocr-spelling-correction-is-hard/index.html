<!doctype html><html lang=en><head><script defer src=https://unpkg.com/@tinybirdco/flock.js data-host=https://api.tinybird.co data-token=p.eyJ1IjogImMwMjJhMjg1LWJmY2YtNDc0OC1hYzczLTJhMDQ1Njk3NTI0YyIsICJpZCI6ICIzNjc3NjQ3Ny04MTE2LTRmYWQtYjcwMy1iZmM3YjMwZGJjMjMifQ.A0vHm-VWbXG6uBFZiwuspN_AyfSYNrdZE3IgwgWSt4g></script><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Max Halford"><meta property="og:url" content="https://maxhalford.github.io/blog/ocr-spelling-correction-is-hard/"><link rel=canonical href=https://maxhalford.github.io/blog/ocr-spelling-correction-is-hard/><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦”</text></svg>"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/maxhalford.github.io\/"},"articleSection":"blog","name":"OCR spelling correction is hard","headline":"OCR spelling correction is hard","description":"I recently saw SymSpell pop up on Hackernews. It claims to be a million times faster than Peter Norvig\u0026rsquo;s spelling corrector. I think it\u0026rsquo;s great that there\u0026rsquo;s a fast open source solution for spelling correction. But in my experience, the most challenging aspect of spelling correction is not necessarily speed.\nWhen I worked at Alan, I mostly wrote logic to extract structured information from medical documents. After some months working on the topic, I have to admit I hadn\u0026rsquo;t cracked the problem.","inLanguage":"en-US","author":"Max Halford","creator":"Max Halford","publisher":"Max Halford","accountablePerson":"Max Halford","copyrightHolder":"Max Halford","copyrightYear":"2022","datePublished":"2022-03-06 00:00:00 \u002b0000 UTC","dateModified":"2022-03-06 00:00:00 \u002b0000 UTC","url":"https:\/\/maxhalford.github.io\/blog\/ocr-spelling-correction-is-hard\/","keywords":["text-processing"]}</script><title>OCR spelling correction is hard â€¢ Max Halford</title><meta property="og:title" content="OCR spelling correction is hard â€¢ Max Halford"><meta property="og:type" content="article"><meta name=description content="I recently saw SymSpell pop up on Hackernews. It claims to be a million times faster than Peter Norvig&rsquo;s spelling corrector. I think it&rsquo;s great that there&rsquo;s a fast open source solution for spelling correction. But in my experience, the most challenging aspect of spelling correction is not necessarily speed.
When I worked at Alan, I mostly wrote logic to extract structured information from medical documents. After some months working on the topic, I have to admit I hadn&rsquo;t cracked the problem."><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/highlight/github.css><link rel=stylesheet href=/css/index.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Permanent+Marker&display=swap" rel=stylesheet><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><article class=post id=article><div class="row center-xs" style=text-align:left><div class="col-xs-12 col-sm-10 col-md-7 col-lg-5"><div class=header><header class=header-parts><div class="signatures site-title"><a href=/>Max Halford ðŸ¦”</a></div><div class=header-links><a class=header-link href=/>Blog</a>
<a class=header-link href=/links/>Links</a>
<a class=header-link href=/bio/>Bio</a></div></header></div><header class=post-header><h1 class=post-title>OCR spelling correction is hard</h1><div class="row post-desc"><div class="col-xs-12 post-desc-items"><time class=post-date datetime="2022-03-06 00:00:00 UTC">2022-03-06</time>
<span class=posts-line-tag>text-processing</span></div></div></header><div class="post-content markdown-body"><p>I recently saw <a href="https://news.ycombinator.com/item?id=30576435">SymSpell</a> pop up on Hackernews. It claims to be a million times faster than <a href=https://norvig.com/spell-correct.html>Peter Norvig&rsquo;s spelling corrector</a>. I think it&rsquo;s great that there&rsquo;s a fast open source solution for spelling correction. But in my experience, the most challenging aspect of spelling correction is not necessarily speed.</p><p>When I <a href=/blog/one-year-at-alan>worked at Alan</a>, I mostly wrote logic to extract structured information from medical documents. After some months working on the topic, I have to admit I hadn&rsquo;t cracked the problem. The goal was to process >80% of documents with no human interaction, but when I left we had only reached 35%. However, I developed a good understanding of what made this task so difficult.</p><p>First, it&rsquo;s worth thinking about why spelling correction is necessary in the context of OCRs. OCRs are used to convert images to text. The OCR identifies characters along with their positions in the image. It packs nearby characters into words that make sense. Usually one would write parsers, such as regex rules, to extract structured information. These parsers are sensitive to typos. OCRs make mistakes, that&rsquo;s a given. A good OCR usually has some kind of post-processing mechanism to correct characters, so that the words they belong to make sense. But this is not foolproof. Alas, good OCRs are often commercial, so we don&rsquo;t know how they work in detail. Moreover, we have no control over the post-processing mechanism. We have to implement our own post-processing logic if we want to correct the OCR&rsquo;s outputs.</p><p>Spelling correctors are usually based on a lexicon of words. They start by splitting a sentence into words &ndash; sometimes they support $n$-grams. Each word is edited by inserting, deleting, substituting, and sometimes transposing characters. Many variations are generated for a given word. Only the words that are part of the lexicon are kept, while the others are cast aside. At last, they use a probabilistic model to decide which correction is the most likely. This is essentially how every <a href=https://www.wikiwand.com/en/Noisy_channel_model>noisy channel model</a> functions.</p><p>There are a few issues which make vanilla spelling correctors unsuitable for post-processing OCR outputs. First of all, a typical document processing task is to extract specific entities, such as dates, currency amounts, and identifiers. These kind of entities are not part of the lexicons which spelling correctors are usually trained on. For instance, Peter Norvig uses words from comprehensive English sources, such as Project Gutenberg, Wiktionary, and the British National Corpus. The issue is that if I&rsquo;m looking to extract a currency amount, say &ldquo;70.58â‚¬&rdquo;, then the spelling corrector won&rsquo;t be of any use, because that token is not part of the spelling corrector&rsquo;s lexicon. In my experience, I noticed that OCRs make more errors on such &ldquo;non-word&rdquo; entities, thereby confirming that their spelling correction step is limited by their lexicon.</p><p>I noticed in practice that Google&rsquo;s and Amazon&rsquo;s OCRs make more mistakes for dates and currency amounts than for regular words. I haven&rsquo;t taken the time to quantify this but I&rsquo;m quite confident it is the case. It made me realise that I was lucky to be working with the French language. Indeed, if you&rsquo;re working with a rarer language, then it&rsquo;s likely that the OCR&rsquo;s spelling corrector is weaker, due to the lack of comprehensive lexicons. For instance, see <a href=https://arxiv.org/pdf/2011.03502.pdf>this article</a> which discusses OCR post-correction for Finnish, as well as <a href=https://skemman.is/bitstream/1946/12085/1/Post-Correction%20of%20Icelandic%20OCR%20Text.pdf>this Master&rsquo;s degree</a> by JÃ³n FriÃ°rik DaÃ°ason for Icelandic. The takeaway is that you need a language model which is tailored towards your target language. In my case, my target language was made up of dates and currency amounts. Therefore, I have to build a bespoke language model.</p><p>In theory, it&rsquo;s possible to circumvent this lexicon issue by augmenting it with all the entities we might be looking for. Indeed, in the case of dates, there are only so many of them we can expect to see in a document, even if we consider different date formats. For instance, if I were looking for the date a patient went to see a doctor, then I would assume that it&rsquo;s likely going to be a date in the last three months. The downside here is that this isn&rsquo;t a very generic approach, and a specific lexicon has to be specified for every field we&rsquo;re looking to extract.</p><p>There&rsquo;s another issue with vanilla spelling correctors. The number of candidates they consider grows exponentially with the number of allowed edits. This limits spelling correctors to consider candidates up to three, sometimes four edits. Anything above that is too computationally prohibitive. The trick is that OCRs make different kind of mistakes than humans do. They can make mistakes with a high number of edits, but these edits are often substitutions or inserted blank spaces. Moreover, substituted characters are usually morphologically similar to the correct character.</p><p>Consider the token <code>IZIo212O21</code>. It&rsquo;s actually a date: <code>17/02/2021</code>. The edit distance is 6 because there are six characters to modify:</p><pre tabindex=0><code>IZIo212O21
1
1ZIo212O21
 7
17Io212O21
  /
17/o212O21
   0
17/0212O21
     /
17/02/2O21
       0
17/02/2021
</code></pre><p>The edit distance to, say, <code>PZIo212O21</code>, is only 1. And yet it&rsquo;s very unlikely that an <code>I</code> gets interpreted as a <code>P</code> by an OCR, so it&rsquo;s not really worth taking the time to consider that correction. It would be more efficient to only consider likely candidates. That way, we could consider candidates which are further away in terms of number of edits, but are actually likely. Indeed, <code>IZIo212O21</code> and <code>17/02/2021</code> are not that different morphologically speaking. The characters look the same. The OCR just had a hard time making the different between similar characters, such as <code>o/0</code> and <code>Z/7</code>. The OCR&rsquo;s postprocessor didn&rsquo;t manage to recognize <code>IZIo212O21</code> is a date, because dates are not part of its lexicon, and there are too many edits to consider.</p><p>I would go as far as suggesting that the same kind of pruning logic could be applied to user input correction. For instance, on a QWERTY keyboard, there&rsquo;s not much sense in considering if a Q was inverted with an M, because both keys are very distant on the keyboard. It&rsquo;s more worthwhile to consider candidates which contain more characters edits, but which are more closer in terms of keyboard layout distance. I wrote a little <a href=https://github.com/MaxHalford/clavier>proof of concept</a> in Python to do just that. But anyway, the concern of this blog post are OCR outputs, not user inputs.</p><p>I hope this blog post does a solid job of shedding some light on why OCR post-processing is so hard. In particular, I want to emphasize that out-of-the-box spelling correctors don&rsquo;t work well enough on this task. My gut feeling is that a whole other approach is necessary to reach very good results. As of now, I haven&rsquo;t seen anything suitable in the open source world. I have however been inspired by a few papers:</p><ul><li><a href=https://aclanthology.org/W96-0108.pdf>A Statistical Approach to Automatic OCR Error Correction in Context</a></li><li><a href=https://aclanthology.org/P98-2152.pdf>Japanese OCR Error Correction using Character Shape Similarity and Statistical Language Model</a></li><li><a href=http://cidrdb.org/cidr2020/papers/p31-sheng-cidr20.pdf>Migrating a Privacy-Safe Information Extraction System to a Software 2.0 Design</a></li><li><a href=https://aclanthology.org/2020.conll-1.35.pdf>Alleviating Digitization Errors in Named Entity Recognition for Historical Documents</a></li></ul><p>I did some research in various directions when I had spare time at Alan. But now I don&rsquo;t work there, so I have less incentive to work on this. However, I am compiling my ideas into a piece of software called <a href=https://github.com/MaxHalford/orc>orc</a>. Admittedly, I&rsquo;m moving forward at a turtle&rsquo;s pace, but I will eventually get somewhere. Furthermore, I&rsquo;m keen to bounce ideas off someone, so feel free to get in touch if this topic is of interest to you.</p></div><script type=text/javascript>var s=document.createElement("script");s.setAttribute("src","https://utteranc.es/client.js"),s.setAttribute("repo","MaxHalford/maxhalford.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",null),s.setAttribute("theme","github-light"),document.body.appendChild(s)</script><div style=display:flex;flex-direction:row;justify-content:center;align-items:center;gap:20px;margin-bottom:30px><div class=do-the-thing><div class=elevator><svg class="sweet-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" enable-background="new 0 0 100 100" height="100" width="100"><path d="M70 47.5H30c-1.4.0-2.5 1.1-2.5 2.5v40c0 1.4 1.1 2.5 2.5 2.5h40c1.4.0 2.5-1.1 2.5-2.5V50C72.5 48.6 71.4 47.5 70 47.5zm-22.5 40h-5v-25h5v25zm10 0h-5v-25h5v25zm10 0h-5V60c0-1.4-1.1-2.5-2.5-2.5H40c-1.4.0-2.5 1.1-2.5 2.5v27.5h-5v-35h35v35z"/><path d="M50 42.5c1.4.0 2.5-1.1 2.5-2.5V16l5.7 5.7c.5.5 1.1.7 1.8.7s1.3-.2 1.8-.7c1-1 1-2.6.0-3.5l-10-10c-1-1-2.6-1-3.5.0l-10 10c-1 1-1 2.6.0 3.5 1 1 2.6 1 3.5.0l5.7-5.7v24c0 1.4 1.1 2.5 2.5 2.5z"/></svg>Back to the top</div></div><iframe src=https://github.com/sponsors/MaxHalford/button title="Sponsor MaxHalford" height=32 width=114 style=border:0;border-radius:6px></iframe></div><script src=https://cdnjs.cloudflare.com/ajax/libs/elevator.js/1.0.1/elevator.min.js></script>
<script>var elementButton=document.querySelector(".elevator"),elevator=new Elevator({element:elementButton,mainAudio:"/music/elevator.mp3",endAudio:"/music/ding.mp3"})</script><style>.down-arrow{font-size:120px;margin-top:90px;margin-bottom:90px;text-shadow:0 -20px #0c1f31,0 0 #c33329;color:transparent;-webkit-transform:scaleY(.8);-moz-transform:scaleY(.8);transform:scaleY(.8)}.elevator{text-align:center;cursor:pointer;width:140px;margin:auto}.elevator:hover{opacity:.7}.elevator svg{width:40px;height:40px;display:block;margin:auto;margin-bottom:5px}</style><div class=related-content><h3 style=margin-top:10px!important;margin-bottom:10px!important>Related posts</h3><ul style=margin-top:0><li><a href=/blog/unsupervised-text-classification/>Unsupervised text classification with word embeddings</a></li><li><a href=/blog/sklearn-text-classifier-memory-footprint-reduction/>Reducing the memory footprint of a scikit-learn text classifier</a></li><li><a href=/blog/textract-table-to-pandas/>Converting Amazon Textract tables to pandas DataFrames</a></li></ul></div></div></div></article><script></script></body></html>